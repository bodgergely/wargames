<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<LINK REL="shortcut icon" HREF="/favicon.ico">
<LINK REL="stylesheet" TYPE="text/css" HREF="/css.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="robots" CONTENT="index,follow,noarchive">
<TITLE>Chris Friedhoff - POSIXFileCaps</TITLE>
</HEAD>
<BODY>
<A NAME="top"></A>
<TABLE CLASS="tb">
<TR><TD CLASS="tdb" COLSPAN="2"><IMG CLASS="ia" SRC="/img/tp.jpg" ALT="Chris Friedhoff"></TD><TR>
<TR><TD CLASS="tdc" COLSPAN="2"><TABLE CLASS="tc"><TR><TD CLASS="tdd"><A CLASS="aa" HREF="/posixfilecaps-print.html">printerFriendly</A></TD></TR></TABLE></TD></TR><TD ALIGN="center" VALIGN="top" WIDTH="1" CLASS="tde"><TABLE CLASS="td"><TR><TD><IMG ALT="" BORDER="0" HEIGHT="1" SRC="/share/opac.gif" WIDTH="4"></TD><TD><IMG ALT="" BORDER="0" HEIGHT="1" SRC="/share/opac.gif" WIDTH="10"></TD><TD><IMG ALT="" BORDER="0" HEIGHT="1" SRC="/share/opac.gif" WIDTH="10"></TD><TD><IMG ALT="" BORDER="0" HEIGHT="1" SRC="/share/opac.gif" WIDTH="70"></TD></TR><TR><TD></TD><TD COLSPAN="3" CLASS="tdf"><A CLASS="ab" HREF="/index.html">Home</A></TD></TR>
<TR><TD></TD><TD COLSPAN="3" CLASS="tdf"><A CLASS="ab" HREF="/lifebook.html">LifeBook</A></TD></TR>
<TR><TD></TD><TD COLSPAN="3" CLASS="tdf"><A CLASS="ab" HREF="/ma311.html">MA311</A></TD></TR>
<TR><TD></TD><TD COLSPAN="3" CLASS="tdf"><A CLASS="ab" HREF="/survivingvim.html">SurvivingVim</A></TD></TR>
<TR><TD></TD><TD COLSPAN="3" CLASS="tdf"><A CLASS="ab" HREF="/playingvim.html">PlayingVim</A></TD></TR>
<TR><TD></TD><TD COLSPAN="3" CLASS="tdf"><A CLASS="ab" HREF="/survivingshell.html">SurvivingShell</A></TD></TR>
<TR><TD></TD><TD COLSPAN="3" CLASS="tdf"><A CLASS="ab" HREF="/lesezugriff.html">Lesezugriff</A></TD></TR>
<TR><TD></TD><TD COLSPAN="3" CLASS="tdg"><A CLASS="ac" HREF="/posixfilecaps.html">POSIXFileCaps</A></TD></TR>
<TR><TD></TD><TD COLSPAN="3" CLASS="tdf"><A CLASS="ab" HREF="/downloads.html">Downloads</A></TD></TR>
<TR><TD></TD><TD COLSPAN="3" CLASS="tdf"><A CLASS="ab" HREF="/odin.html">Odin</A></TD></TR>
<TR><TD></TD><TD COLSPAN="3" CLASS="tdf"><A CLASS="ab" HREF="/about.html">About</A></TD></TR>
<TR><TD></TD><TD COLSPAN="3" CLASS="tdf"><A CLASS="ab" HREF="/email.html">Email</A></TD></TR>
</TABLE></TD>
<TD VALIGN="top" CLASS="tdl"><TABLE CLASS="tg">
<TR><TD CLASS="tdm">POSIX Capabilities & File POSIX Capabilities</TD></TR>
<TR><TD CLASS="tdo"><h2>!!! I'm about to rewrite this page. Hence I haven't finished so, the old page is still available <a href="/posixfilecapsold.html">here</a>. !!!</h2><BR>With the inclusion of File POSIX Capabilities in Kernel 2.6.24 has Linux finally reached a stage, where POSIX Capabilities are usable and useful. Although POSIX Capabilities arrived at Kernel 2.2, the File part waited up to 2.6.24 to make its appearance. Now Linux is closing its gap to other systems in regards of POSIX Capabilities.<BR>Well, from far above, thats true and even closer its not wrong. But there were plans and patches for file support of PCaps for 2.3. Later different patches were also available. Due to a bug called the sendmail bug, they hadn't had enough support. And further an open question was, where actually store the File POSIX Capabilities.<BR>Now the dark age is over and the bright future of POSIX Capabilities in Linux is awaiting us.</TD></TR>
<TR><TD CLASS="tdp">POSIX Capabilities are Privileges. They are called POSIX Capabilities because the POSIX document 1003.1e describes the idea of having a system of privileges - called capabilities -, which are taken into account in the decision of granting a process access to certain actions. As Capabilities are something different - a subject-object-right relationship - these privileges following the idea of the POSIX document 1003.1e are dubbed for Linux POSIX Capabilities.<BR>Practically speaking, the sum of all POSIX Capabilities forms the Root power or the other way around the root power is split up in discrete privileges - POSIX Capabilities.<BR>POSIX Capabilities break with the root model. The everything or nothing principle in regards of privileges is not necessary and not justified. Neither is it adequate to give a program the whole power of root to just open a socket (-> ping) nor to give the user with the back up role this whole power, when he or his tools shall only read all files of all user to back them up. Depending of the set-up, a program itself might hold the necessary privilege to fulfill his task. Not the user credentials are decisive, but the programs privileges are now. The idea of ACLs is in the same POSIX document developed. Combining the shift of granting privileges from users to programs with access control to these programs opens new possibilities in creating privilege distribution models and role models.<BR>The technique of Inheritance opens for the POSIX Capabilities infrastructure further fascinating solutions. Granting users and applications PCaps in a form, where only the adequate user-application PCaps combination results in actually effective privileges.</TD></TR>
<TR><TD CLASS="tdr"><UL CLASS="ua">
<LI CLASS="la"><A HREF="#Types of usage of POSIX Capabilities - Substitution of suid-0 privilege with POSIX Capabilities privilege" CLASS="ae">Types of usage of POSIX Capabilities - Substitution of suid-0 privilege with POSIX Capabilities privilege</A></LI>
<LI CLASS="la"><A HREF="#Types of usage of POSIX Capabilities - Server running as a distinct unprivileged user" CLASS="ae">Types of usage of POSIX Capabilities - Server running as a distinct unprivileged user</A></LI>
<LI CLASS="la"><A HREF="#Types of usage of POSIX Capabilities - Different privilege levels for different user rolls" CLASS="ae">Types of usage of POSIX Capabilities - Different privilege levels for different user rolls</A></LI>
<LI CLASS="la"><A HREF="#Types of usage of POSIX Capabilities - On the code level application inside" CLASS="ae">Types of usage of POSIX Capabilities - On the code level application inside</A></LI>
<LI CLASS="la"><A HREF="#POSIX Capabilities - Capability Flag, Set and State" CLASS="ae">POSIX Capabilities - Capability Flag, Set and State</A></LI>
<LI CLASS="la"><A HREF="#POSIX Capabilities - Permitted Flag, Permitted Set" CLASS="ae">POSIX Capabilities - Permitted Flag, Permitted Set</A></LI>
<LI CLASS="la"><A HREF="#POSIX Capabilities - Effective Flag, Effective Set" CLASS="ae">POSIX Capabilities - Effective Flag, Effective Set</A></LI>
<LI CLASS="la"><A HREF="#POSIX Capabilities - Inheritable Flag, Inheritable Set" CLASS="ae">POSIX Capabilities - Inheritable Flag, Inheritable Set</A></LI>
<LI CLASS="la"><A HREF="#POSIX Capabilities - Capability Rules" CLASS="ae">POSIX Capabilities - Capability Rules</A></LI>
<LI CLASS="la"><A HREF="#Motivation" CLASS="ae">Motivation</A></LI>
<LI CLASS="la"><A HREF="#HowTo - Requirements - Check your system" CLASS="ae">HowTo - Requirements - Check your system</A></LI>
<LI CLASS="la"><A HREF="#HowTo - Kernelspace - Compile and Install" CLASS="ae">HowTo - Kernelspace - Compile and Install</A></LI>
<LI CLASS="la"><A HREF="#HowTo - Userspace - Compile and Install" CLASS="ae">HowTo - Userspace - Compile and Install</A></LI>
<LI CLASS="la"><A HREF="#HowTo - Configuring and Using PCaps" CLASS="ae">HowTo - Configuring and Using PCaps</A></LI>
<LI CLASS="la"><A HREF="#HowTo - Detection of needed capabilities - Intro" CLASS="ae">HowTo - Detection of needed capabilities - Intro</A></LI>
<LI CLASS="la"><A HREF="#HowTo - Detection of needed capabilities - strace" CLASS="ae">HowTo - Detection of needed capabilities - strace</A></LI>
<LI CLASS="la"><A HREF="#HowTo - Detection of needed capabilities - capable_probe module" CLASS="ae">HowTo - Detection of needed capabilities - capable_probe module</A></LI>
<LI CLASS="la"><A HREF="#HowTo - Removing capabilities" CLASS="ae">HowTo - Removing capabilities</A></LI>
<LI CLASS="la"><A HREF="#File system operations - updating distro packages" CLASS="ae">File system operations - updating distro packages</A></LI>
<LI CLASS="la"><A HREF="#File system operations - mv and cp (coreutils)" CLASS="ae">File system operations - mv and cp (coreutils)</A></LI>
<LI CLASS="la"><A HREF="#File system operations - Back up and restore with tar" CLASS="ae">File system operations - Back up and restore with tar</A></LI>
<LI CLASS="la"><A HREF="#File system operations - back up and restore with rsync" CLASS="ae">File system operations - back up and restore with rsync</A></LI>
<LI CLASS="la"><A HREF="#Examples - Substitution of suid-0 privilege with POSIX Capabilities privilege" CLASS="ae">Examples - Substitution of suid-0 privilege with POSIX Capabilities privilege</A></LI>
<LI CLASS="la"><A HREF="#Examples - Server running as a distinct unprivileged user - Apache" CLASS="ae">Examples - Server running as a distinct unprivileged user - Apache</A></LI>
<LI CLASS="la"><A HREF="#Examples - Server running as a distinct unprivileged user - Bind" CLASS="ae">Examples - Server running as a distinct unprivileged user - Bind</A></LI>
<LI CLASS="la"><A HREF="#Examples - Server running as a distinct unprivileged user - Cupsd" CLASS="ae">Examples - Server running as a distinct unprivileged user - Cupsd</A></LI>
<LI CLASS="la"><A HREF="#Examples - Server running as a distinct unprivileged user - DHCPD" CLASS="ae">Examples - Server running as a distinct unprivileged user - DHCPD</A></LI>
<LI CLASS="la"><A HREF="#Examples - Server running as a distinct unprivileged user - SAMBA" CLASS="ae">Examples - Server running as a distinct unprivileged user - SAMBA</A></LI>
<LI CLASS="la"><A HREF="#Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Intro" CLASS="ae">Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Intro</A></LI>
<LI CLASS="la"><A HREF="#Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Installing the bits" CLASS="ae">Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Installing the bits</A></LI>
<LI CLASS="la"><A HREF="#Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Exploring Inheritance" CLASS="ae">Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Exploring Inheritance</A></LI>
<LI CLASS="la"><A HREF="#Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - SUID-BIT 0 reloaded" CLASS="ae">Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - SUID-BIT 0 reloaded</A></LI>
<LI CLASS="la"><A HREF="#Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Convenience" CLASS="ae">Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Convenience</A></LI>
<LI CLASS="la"><A HREF="#Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Different Administration Rolls" CLASS="ae">Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Different Administration Rolls</A></LI>
<LI CLASS="la"><A HREF="#Lectures, Talks and Presentations" CLASS="ae">Lectures, Talks and Presentations</A></LI>
</UL></TD></TR><TR><TD><A NAME="Types of usage of POSIX Capabilities - Substitution of suid-0 privilege with POSIX Capabilities privilege">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Types of usage of POSIX Capabilities - Substitution of suid-0 privilege with POSIX Capabilities privilege</TD></TR>
<TR><TD CLASS="tdp">
A program runs in the privilege context of the user, who has started the process. For some tasks the privilege level of the user is insufficient to achieve the task. To solve this limit, it is possible to run an program in the context of the file owner, which is signified by the suid-bit. Hence referring to the privilege level there are only two user types, the super user aka root and the unprivileged user, the file owner is to overcome the lack-of-privilege-problem obviously root. Resolving the lack of privilege problem by using suid-bit technique results therefore in processes running in the right context and on the power level of root.<BR><BR>A famous example is /usr/bin/passwd which changes the password depending on your configuration in /etc/passwd or /etc/shadow. Whereas world is allowed to read /etc/passwd only user root is allowed to change /etc/passwd or /etc/shadow. To offer nevertheless the unprivileged user the possibility of changing his password, he has to start an application with the required privilege. Because his credential is insufficient the suid bit offers the way to use the credential of the file owner aka root. The file ownership of root in combination with the suid bit and the right to execute this file for the group owner or even world makes it possible for members of the mentioned group or even world to perform an action, where the own level of privileges is not adequate.<BR><BR>The idea of joining the necessary privilege to perform successful a certain action with the executable to call instead of deriving the privileges from the calling user, the idea of the suid bit, is one way of using POSIX Capabilities. The difference is, root is equivalent to granting all for the system available PCaps, whereas with PCaps you can grant just the minimal necessary privileges. Substituting the suid bit root technique with PCaps follows the 'principle of least privilege'.<BR><BR>More technically speaking, a further difference is, that the suid-bit-root privilege handling derives its privileges from the user root, again a user-privileges combination. Where the real user stays the calling unprivileged user, the effective user of the resulting process changes to root.<BR>With PCaps, the through PCaps granted privileges to the binary are connected directly to the binary and in executing the binary the real and effective user don't change.<BR><BR>In the examples section, you will find different suid-0 binaries with their respective PCaps.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Types of usage of POSIX Capabilities - Server running as a distinct unprivileged user">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Types of usage of POSIX Capabilities - Server running as a distinct unprivileged user</TD></TR>
<TR><TD CLASS="tdp">
Server in the sense of software are started either by in the root context running programs or have to be started as root. They are running in the privilege level of root because they are requesting or performing action for which special privileges are necessary. Because with PCaps it is possible to grant individual privileges to binaries, there is no need to give a server process the full set of privileges through running in the root context.<BR>A conceivable server occupies a privilege port, accesses its configuration files and writes log data. We create a user and group solely reserved to this server. We change user and group ownership of the file the server has to write to, his log files, to his user and group. We grant this server the privilege to open privilege ports. We start this server in the context of his user and group. Now we have a server, running as a distinct but unprivileged user, which has just the needed minimal privileges and still protected from other user. If this server goes wild, all the server can do now is in the limit of his granted privileges to his binary, here opening privileges port, and further in the limit of his unprivileged user, for example changing his file. Getting the root level of privileges is through problems in the server software not possible anymore.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Types of usage of POSIX Capabilities - Different privilege levels for different user rolls">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Types of usage of POSIX Capabilities - Different privilege levels for different user rolls</TD></TR>
<TR><TD CLASS="tdp">
The everything or nothing of the privilege root model can be substituted. Now we can grant users certain privileges, which are only becoming effective with binaries, which are expect to be called by a process, and a logged in user is system intern one or more processes, who has also this privileges. The sets of PCaps of the calling process and the called binary have to match to be effective. Effective in the sense that only by matching the PCap will be granted the Permitted (p) Flag.<BR>A PAM based login process grants according to the configuration a user a set of POSIX Capabilities to his Inheritance Set. Now this user can start a process of which the corresponding binary expect through his Inheritance Set to be called by a process with the same POSIX Capabilities in his Inheritance Set. Unprivileged user, without the required PCaps in their Inheritance Set, won't be able to start the binary successful. The resulting process will lack the needed privileges and because of this will bail out or fail.<BR>Applicable is this concept in two directions. Granting additional privileges to user and preparing the corresponding applications will enables this user to call and execute that application successful. Imaginable are back up roles in combination with back up tools, the user is allowed to cross ownership limits for reading files, or time changing roles, module loading roles or network interface configuration roles.<BR>The other direction looks at former suid-0 binaries. Not enabling them for every user but only for adequate empowered user, results in user roles without these privilege. This users will not even allowed to call and execute programs, which are today through suid-0 accessible.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Types of usage of POSIX Capabilities - On the code level application inside">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Types of usage of POSIX Capabilities - On the code level application inside</TD></TR>
<TR><TD CLASS="tdp">
The easiest way of handling privileges is ignoring them. Just execute. If the level of privilege is not sufficient, the system gives a permission denied. By checking the return code, the program is more friendly in stopping instead remaining in an undefined state.<BR>Checking for being called as root, if the program needs privileges is another way. If not executed as root exit with an error message.<BR>Using PCaps without relying on granted PCaps means expecting to be started as root, decreasing into an unprivileged user and keeping the PCaps, that are necessary.<BR>PCaps aware means checking on program start for the needed PCaps in the Permitted Set and clearing the Effective Sate. Setting needed PCaps around the adequate code Effective and leave them otherwise only in the Permitted Set. Further remove PCaps from the Permitted Set if not needed anymore.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="POSIX Capabilities - Capability Flag, Set and State">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">POSIX Capabilities - Capability Flag, Set and State</TD></TR>
<TR><TD CLASS="tdp">
The Capability Flag is a per-capability attribute. The Capability Flags are named Permitted (p), Effective (e) and Inheritable (i). These flags apply to each capability separately.<BR>All POSIX Capabilities, which have a certain Flag form the respective Set. So there exists the Permitted (P), Effective (E) and Inheritable (I) Set.<BR>All POSIX Capabilities with all their Flags form the POSIX Capability State. The POSIX Capability State contains therefor all three Sets (obviously).</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="POSIX Capabilities - Permitted Flag, Permitted Set">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">POSIX Capabilities - Permitted Flag, Permitted Set</TD></TR>
<TR><TD CLASS="tdp">
The Permitted Flag (p) marks a PCap as available. The Permitted Set (P) is the sum of all PCaps with the Permitted Flag.<BR><BR>The File Permitted Set (fP) forces the PCap into the Permitted Set of the resulting process. The File Permitted Set is also called the Forced Set.<BR><BR>The Permitted Set of a process, the Process Permitted Set (pP), contains all PCaps a process can use. The Process Permitted Set marks also the maximum set of all usable PCaps for a process. For processes only PCaps in the Permitted Set may have the Effective and / or Inheritable Flag rsp be part of the Effective Set and / or Inheritable Set.<BR>To enhance the security, process may also irrevocable delete PCaps out of his Permitted Set, if the process doesn't need them anymore.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="POSIX Capabilities - Effective Flag, Effective Set">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">POSIX Capabilities - Effective Flag, Effective Set</TD></TR>
<TR><TD CLASS="tdp">
The Effective Flag (e) marks a PCap as armed, in effect and direct usable for a process. The Effective Set (E) is the sum of all PCaps with the Effective Flag.<BR><BR>PCaps of the File Effective Set (fE) must also have the Permitted Flag or the Inheritable Flag. The File Effective Set (fE) populates the Process Effective Set of the resulting process if and only if the PCaps is also in the Process Permitted Set of the resulting process.<BR>PCaps unaware programs are not capable of populating their Effective Set them self. This has to be done through the File Effective Set of their respective executable.<BR><BR>PCaps of the Process Effective Set (pE) give the associated privilege to the now running process respectively to the sequence of the now executed code. PCaps of the Process Effective Set must also be part of the Process Permitted Set. A PCaps aware program will raise and lower itself his PCaps into and out of his Effective Set on a as-needed basis.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="POSIX Capabilities - Inheritable Flag, Inheritable Set">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">POSIX Capabilities - Inheritable Flag, Inheritable Set</TD></TR>
<TR><TD CLASS="tdp">
The Inheritable Flag (i) marks a Pcap as hereditary/heritable (erbbar) for file or inheritable (vererbbar) for processes. The Inheritable Set (I)is the sum of all PCaps with the Inheritable Flag.<BR><BR>The File Inheritable Set (fI) contains PCaps which go only into the per exec() resulting Process Permitted Set (pP') if the calling process has the same PCaps in his Process Inheritable Set (pI).<BR>The File Inheritable Set migrates not in the new Process Inheritable Set (pI'). The calling Process Inheritable Set (pI) becomes unchanged the new Process Inheritable Set.<BR><BR>PCaps aware applications may change, clear or populate their own Process Inheritance Set. PCaps unaware applications pass the Process Inheritance Set unchanged to a new per exec() created process.<BR><BR>By using PCaps Inheritance, only selected processes with the adequate Process Inheritance Set may call and execute successful applications with accordingly prepared File Inheritance Sets.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="POSIX Capabilities - Capability Rules">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">POSIX Capabilities - Capability Rules</TD></TR>
<TR><TD CLASS="tdo">
The POSIX Capability State is calculated upon an exec(). A forc() or clone() doesn't change the PCaps State.<BR>As defined in 1003.1e p. 17</TD></TR>
<TR><TD CLASS="tdp">
<b>Definition:</b><BR><BR>    p{I,P,E}' = post-exec() POSIX Capability Sets aka the PCaps State of the new process<BR>    X  = was not specified by 1003.1e and has subsequently become cap_bset - /proc/sys/kernel/cap-bound for Linux<BR>    fP = File Permitted Set of the called executable, also Minimal Forced Set called<BR>    fE = File Effective Set of the called executable<BR>    fI = File Inheritance Set of the called executables<BR>    pP = Process Permitted Set (here of the calling process)<BR>    pE = Process Effective Set (here of the calling process)<BR>    pI = Process Inheritable Set (here of the calling process)<BR>    & --> Intersection<BR>    | --> Union<BR><BR><BR><b>Rules:</b><BR><BR><pre>    1)  pI' = pI<BR>    2)  pP' = (X & fP) | (pI & fI)<BR>    3)  pE' = fE & pP'</pre><BR><BR><BR><b>Explanation:</b><BR><BR>1) The Process Inheritable Set (pI) of the calling process becomes unchanged the Process Inheritable Set (pI') of the newly created process. So exec() is not changing the Process Inheritable Set.<BR><BR>2) The Process Permitted Set (pP') of the per exec() newly created process is the union of two intersections. The first is the intersection of the system upper limit of possible PCaps (X) with the File Permitted Set (fP). The second is the intersection of the calling Process Inheritable Set (pI) with the File Inheritable Set (fI). In one sentence explained is the Process Permitted Set of the per exec() created process the union of the intersection of the system upper limit with the File Permitted Set and the intersection of the Process Inheritable set with the File Inheritable Set.<BR><BR>3) The Process Effective Set (pE') of the newly created process per exec() is the intersection of the File Effective Set (fE) with the Process Permitted Set (pP') of the newly created process.<BR><BR><BR><b>Discussion:</b><BR><BR>1) Through the transmission of the unchanged Process Inheritable Set (pI), as far as no PCaps aware application changes this set for them self and the following processes, is it possible for a user with his Inheritabtle Set to kick off and execute successful a chain of applications if his Inheritable Set meets the File Inheritable Sets (fI) of the called applications.<BR><BR>2) The effect of the File Permitted Set (fP), also called Minimal Forced Set, is limited through the System Wide Upper Limit (X).<BR>A process gains its PCaps with Permitted Flags either through File Permitted Set (fP) (Minimal Forced Set) limited by the System Upper Level (X), or through the intersection of the calling Process Inheritable Set (pI) with the called File Inheritable Set (fI). By relying totally on inheritance a program can only be successfully executed, when both the caller and called have the same necessary PCaps in their Inheritable Set. Hence its possible to selectively allow only certain processes the succesful execution of adequately configured executables.<BR><BR>3) After computing the new Process Permitted Set (pP'), only the PCaps which are in both the File Effective Set (fE) and the Process Permitted Set (pP') can be in the initial Process Effective Set (pE'). Initial because if the application is PCaps aware it will clear and populate himself his Process Effective Set. For PCaps unaware application it is evidently crucial, that the needed PCaps have to be in the Process Effective Set (pE) and therefor in the Process Permitted Set (pP).<BR><BR><BR><b>Remark: Dependencies of Sets</b><BR><BR>PCaps of File Effective Set have either to be part of the File Permitted Set or the File Inheritable Set.<BR>Only PCaps of the Process Permitted Set can be part of the Process Effective Set or the Process Inheritable Set.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Motivation">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Motivation</TD></TR>
<TR><TD CLASS="tdp">
The kernel version 2.6.18 introduced the privilege requirement to have the CAP_NET_ADMIN capability to create a tuntap interface. I was using qemu (www.qemu.org). To interact with a virtual machine you need a lan connectivity through a tuntap interface. Qemu needed from now on this privilege and through lack of alternatives root privilege. I was uneasy having a not so trusty os running in an suid-0 container. First I patched the three lines out of the kernel<BR><pre>diff -ruN linux-2.6.18-orig/drivers/net/tun.c linux-2.6.18/drivers/net/tun.c<BR>--- linux-2.6.18-orig/drivers/net/tun.c 2006-09-20 05:42:06.000000000 +0200<BR>+++ linux-2.6.18/drivers/net/tun.c      2006-10-02 09:21:52.000000000 +0200<BR>@@ -489,9 +489,6 @@<BR><BR>                err = -EINVAL;<BR><BR>-               if (!capable(CAP_NET_ADMIN))<BR>-                       return -EPERM;<BR>-<BR>                /* Set dev type */<BR>                if (ifr->ifr_flags & IFF_TUN) {<BR>                        /* TUN device */</pre><BR>and I was back where I was before 2.6.18, but this was not super elegant. In the process of understanding capabilities I found Serges Hallyn's fscaps patch and applied it. I accompanied this patch with tests and documentation. It made it into 2.6.19-rc5-mm2 and stayed for one year in the -mm tree to mature. With 2.6.24-rc2 entered the patch now named 'posix file capabilities' mainline to form the option 'File POSIX Capabilities' under security. KaiGai Kohei was from the end of 2006 to the end of 2007 (11?) providing the user space tools by adding different patches to the libcap1 package. At the end of 2007 Andrew Morgan was again taking care of his libcap packages and with the changes from KaiGai it became the libcap2 package.<BR><BR>The initial reception of the first version summer 2006 of fscaps patch was friendly but reserved. The second version in 10/2006 hadn't gained more attention. It was like asking "who needs this what for". I was the one who had a real use of this patch and was happy about it. And I started again the discussion on LKML. I gave test comments and wrote a documentation to help others to use the patch. Slowly the train started to move and a 'give it a round in -mm' brought it into the -mm tree. For a patch being in -mm, it got more attention, but it has taken one year.<BR><BR>The coincidence chain was qemu-tuntap-2.6.18-cap_net_admin-me. I thought after File POSIX Capabilities went mainline everyone would be happy to substitute suid-0 binaries through File POSIX Capabilities. But nothing happens. So I do my part in spreading the news and promise of this technique through writing documentation, giving talks and coding conversion tools.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="HowTo - Requirements - Check your system">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">HowTo - Requirements - Check your system</TD></TR>
<TR><TD CLASS="tdo">
You will need<BR>- a kernel >= 2.6.24<BR>- a filesystem that supports extended attributes like ext3<BR>- File POSIX Capabilities enabled<BR>- libcap2 package >=2.08</TD></TR>
<TR><TD CLASS="tdp">
Check the Kernel with<BR><pre>$ uname -r</pre><BR><BR>Check your Kernel Config by<BR><pre>$ grep '&#092;(XATTR&#092;|CAPA&#092;)' /boot/config-`uname -r`<BR>$ zgrep '&#092;(XATTR&#092;|CAPA&#092;)' /proc/config.gz<BR>CONFIG_EXT3_FS_XATTR=y<BR>CONFIG_SECURITY_CAPABILITIES=y<BR>CONFIG_SECURITY_FILE_CAPABILITIES=y</pre><BR><BR>Check your libcap package<BR><pre>$ ls -l /lib/libcap.so*<BR>lrwxrwxrwx 1 root root    11 Mar  9 10:58 /lib/libcap.so -> libcap.so.2<BR>lrwxrwxrwx 1 root root    14 Mar  9 10:58 /lib/libcap.so.2 -> libcap.so.2.08<BR>-rw-r--r-- 1 root root 14660 Mar  9 10:54 /lib/libcap.so.2.08</pre></TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="HowTo - Kernelspace - Compile and Install">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">HowTo - Kernelspace - Compile and Install</TD></TR>
<TR><TD CLASS="tdo">
If your distribution repository has not an adequate configured kernel, you have to build your own kernel.</TD></TR>
<TR><TD CLASS="tdp">
Since 2.6.24-rc2 the file system support for POSIX Capabilities is part of mainline. So there is no kernel patching needed. Because the PCaps for files are stored in the extended attributes of that file, a further prerequisite is a file system, that supports extended attributes like ext3.<BR><BR><b>kernel make menuconfig</b><BR><BR><pre>Security options  ---><BR>    Enable different security models<BR>        Default Linux Capabilities<BR>    File POSIX Capabilities (EXPERIMENTAL)<BR>File systems  ---><BR>    Ext3 journalling file system support<BR>        Ext3 extended attributes</pre><BR><BR>If you are working with "different security model" option, than check for "Default Linux Capabilities"<BR><pre>Security options  ---><BR>    Enable different security models<BR>        Default Linux Capabilities</pre><BR><BR>After you finished your kernel configuration, call make, make modules_install, copy your new kernel to /boot, update your boot loader and reboot.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="HowTo - Userspace - Compile and Install">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">HowTo - Userspace - Compile and Install</TD></TR>
<TR><TD CLASS="tdo">
If your distribution repository has not an adequate libcap2 package, you have to build your own libcap2 package.</TD></TR>
<TR><TD CLASS="tdp">
Since version 2.03 Andrew Morgan's libcap2 package supports 32-bit (mainline -rc of 2.6.24) and 64-bit (-mm of 2.6.24) capabilities. KaiGai Kohei's developments are integrated into the libcap2 package. You will find the tools setcap to set File PCaps State, getcap to read File PCaps State and getpcap to get the Process PCaps State.<BR>Note: As a discussion on LKML revealed, SUSE's libcap-1.92 package in SuSE-9.1 to SUSE-10-1 is not compatible to kernel >= 2.6.25 (24?) and might break apps. Replace this package with the old and original libcap-1.97, if you don't want to use PCaps or libcap-2.08, if you want to use PCaps.<BR>[<a href="http://lkml.org/lkml/2008/4/22/18">http://lkml.org/lkml/2008/4/22/18</a>]<BR><BR><b>Andrew Morgan's libcap2</b><BR><BR>Get the libcap2 package, extract, compile and install it.<BR><BR><pre>$ tar xjf libcap-2.xx.tar.bz2<BR>$ cd libcap-2.xx<BR>$ make<BR>$ sudo make install</pre><BR><BR>Its a good idea to test your configuration by executing quicktest.sh in root context.<BR><BR><pre>$ cd progs<BR>$ sudo ./quicktest.sh</pre></TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="HowTo - Configuring and Using PCaps">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">HowTo - Configuring and Using PCaps</TD></TR>
<TR><TD CLASS="tdo">
After building, installing and rebooting the new kernel with extended attributes and File POSIX Capabilities and compiling and installing the userspace tools, we use setcap and getcap to do the work.</TD></TR>
<TR><TD CLASS="tdp">
To get an idea of the available capabilities have a look at<BR><BR><pre>less /usr/include/linux/capability.h<BR>man capabilities</pre><BR><BR>This will clarify the complete set of capability the root power consist of. It is not justified to arm a binary or process with all these capabilities, when its just shopping for a raw socket. Only the lack of mean to adequately equip a binary with the appropriate set of capabilities has leaded to suid-0 binaries.<BR><BR>Granting a PCap is as simple as<BR><pre>$ sudo setcap cap_net_admin=ep /bin/ping</pre><BR><BR>Reading granted capabilities is as simple as<BR><pre>$ getcap /bin/ping<BR>/bin/ping: = cap_net_raw+ep</pre><BR><BR>Checking the extended attribute<BR><pre>$ attr -l /bin/ping<BR>Attribute "capability" has a 12 byte value for /bin/ping</pre><BR><BR>Removing PCaps<BR><pre>$ sudo setcap -r /bin/ping</pre></TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="HowTo - Detection of needed capabilities - Intro">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">HowTo - Detection of needed capabilities - Intro</TD></TR>
<TR><TD CLASS="tdo">
ping is a nice tool to exercise the hunt for the necessary capabilities. It is a root owned suid-bit-0 binary. All the commands will be executed by an unprivileged user. If we need root power, we will use sudo.</TD></TR>
<TR><TD CLASS="tdp">
By checking ping with ls -l we see the suid-bit (s) and that it is root owned. By executing, we see it works.<BR><pre>$ ls -l /bin/ping<BR>-rws--x--x 1 root root 29364 2006-08-14 00:20 /bin/ping<BR>$ ping -c 1 localhost<BR>PING localhost (127.0.0.1) 56(84) bytes of data.<BR>64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.111 ms<BR><BR>--- localhost ping statistics ---<BR>1 packets transmitted, 1 received, 0% packet loss, time 0ms<BR>rtt min/avg/max/mdev = 0.111/0.111/0.111/0.000 ms</pre><BR><BR>Now by removing the suid-bit, ping - as expected - can't do it's work by lack of the needed capability.<BR><pre>$ sudo chmod u-s /bin/ping<BR>$ ping -c 1 localhost<BR>ping: icmp open socket: Operation not permitted</pre><BR><BR>Hence the error message is not very explicative, we try strace.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="HowTo - Detection of needed capabilities - strace">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">HowTo - Detection of needed capabilities - strace</TD></TR>
<TR><TD CLASS="tdo">
strace is a diagnostic tool, which intercepts and records called system calls by a process and the signals which are received by this process by giving the name of each system call, its arguments and its return value. The EPERM error signifies that the caller was not privileged to call a certain function or resource.</TD></TR>
<TR><TD CLASS="tdp">
<pre>$ strace ping localhost 2>&1 | grep EPERM<BR>socket(PF_INET, SOCK_RAW, IPPROTO_ICMP) = -1 EPERM (Operation not permitted)</pre><BR><BR>The caller ping lacks the privilege to create a socket of type SOCK_RAW. /usr/include/linux/capability.h shows<BR><BR><pre>/* Allow use of RAW sockets */<BR>/* Allow use of PACKET sockets */<BR><BR>#define CAP_NET_RAW          13</pre><BR><BR>This well chosen example showed us easily the needed PCap. You can expect programs that got denied different stuff with -EPERM, which they actually don't need to do. Here to deduce the needed PCaps will be far more complex. But we have another tool at hand.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="HowTo - Detection of needed capabilities - capable_probe module">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">HowTo - Detection of needed capabilities - capable_probe module</TD></TR>
<TR><TD CLASS="tdo">
Serge E. Hallyn provides in his article 'POSIX file capabilities: Parceling the power of root' the source for the module capable_probe. This module helps us to see the requested PCaps by replacing any calls to cap_capable() by a call to cr_capable(). This function prints out the name of the program together with the requested PCaps. Afterwards it calls the cap_capable() function.</TD></TR>
<TR><TD CLASS="tdp">
Under Tools and Patches you will find a link for the package from this site. The included Makefile is expanded for an install target for the running kernel.<BR><BR>Kprobes allows the insertion of probes. It allows to write small kernel modules to run code at the start of a function (jprobe), the end of a function (kretprobe) or at any address (kprobe). Enabling kprobes and the loading of the module capable_probe will allow us to see the PCaps which are required by the kernel to run the program successful.<BR><BR><b>kernel make menuconfig</b><BR><pre>Instrumentation Support  ---><BR>    Kprobes</pre><BR><BR><b>capable_probe</b><BR><pre>tar capable_probe.tar.bz2<BR>cd capable_probe<BR>make<BR>sudo make install</pre><BR><BR>After inserting the capable_probe module, /var/log/messages will contain the program name with the requested capabilities, when the program is executed. Don't forget to unload the module afterwards. Otherwise your /var/log/messages log file gets flooded.<BR>Here we will work with 2 console. The first to observe /var/log/messages and the second to issue the commands.<BR><BR>console1<BR><pre>$ tail -f /var/log/messages/ | grep ping</pre><BR><BR>console2<BR><pre>$ sudo modprobe capable_probe<BR>$ ping localhost<BR>ping: icmp open socket: Operation not permitted<BR>$ sudo modprobe -r capable_probe</pre><BR><BR>console1<BR><pre>...<BR>Dec 26 14:57:21 apollo kernel: cr_capable: asking for capability 21 for ping<BR>Dec 26 14:57:21 apollo kernel: cr_capable: asking for capability 13 for ping<BR>Dec 26 14:57:21 apollo kernel: cr_capable: asking for capability 7 for ping<BR>Dec 26 14:57:21 apollo kernel: cr_capable: asking for capability 21 for ping</pre><BR><BR>Again /usr/include/linux/capability.h clarifies the capabilities 7, 13 and 21.<BR>The capability "7: CAP_SETUID" is not what we want ping to do. We need no setuid manipulation.<BR>The catch-all capability "21: CAP_SYS_ADMIN" is better never granted to any program. We are talking about hardening a system by following the principle of least privilege and not about punching holes in.<BR>Common sens helped us to arrive again at capability "13: CAP_NET_RAW.<BR><BR><b>Granting capabilities - Ping</b><BR>After the long way around we arrived where we started, but now we know, that ping just needs the CAP_NET_RAW capability to send ICMP packets to a host. There is no need to have and run ping anymore as a suid-0 binary.<BR><BR>$ sudo setcap cap_net_raw=ep /bin/ping</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="HowTo - Removing capabilities">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">HowTo - Removing capabilities</TD></TR>
<TR><TD CLASS="tdo">
If for some reason it is necessary or desirable to get rid of File PCaps ...</TD></TR>
<TR><TD CLASS="tdp">
Our favorite binary ping will serve us again as an example.<BR>ping is now a non-suid-0-bit binary and has the cap_net_raw file capability granted.<BR>In restoring the original state we have to remove the cap_net_raw capability and restore the suid-0-bit.<BR><BR>before we restore, we check the point of departure ...<BR><pre>$ getcap /bin/ping<BR>/bin/ping = cap_net_raw+ep<BR>$ ls -l /bin/ping<BR>-rwx--x--x 1 root root 28992 May  9  2007 /bin/ping<BR>$ attr -l /bin/ping<BR>Attribute "capability" has a 12 byte value for /bin/ping</pre><BR><BR>... and here we go back to the original state<BR></pre>$ sudo setcap -r /bin/ping<BR>$ sudo chmod u+s /bin/ping<BR>$ ping -c 1 localhost<BR>PING localhost (127.0.0.1) 56(84) bytes of data.<BR>64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.090 ms<BR><BR>--- localhost ping statistics ---<BR>1 packets transmitted, 1 received, 0% packet loss, time 0ms<BR>rtt min/avg/max/mdev = 0.090/0.090/0.090/0.000 ms</pre><BR><BR>So, that was not very dramatic ...</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="File system operations - updating distro packages">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">File system operations - updating distro packages</TD></TR>
<TR><TD CLASS="tdp">
A system is never static. At least security updates have to be applied, to keep the system as secure as possible.<BR>This maintenance of updating distro packages will unfortunately remove the system hardening with File PCaps as long as distro packages don't support PCaps. Updating a binary results in a new inode of the new binary. So the update of the old binary with his old inode will remove the granted capabilities.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="File system operations - mv and cp (coreutils)">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">File system operations - mv and cp (coreutils)</TD></TR>
<TR><TD CLASS="tdo">
The cli tools mv and cp are part of the coreutils package (http://www.gnu.org/software/coreutils/). As of version coreutils-6.9, the package is except for ACLs not supporting extended attributes. Thanks to the coreutils-xattr.diff patch external support is available.</TD></TR>
<TR><TD CLASS="tdp">
Before the patched coreutils package compiles sucessfully, the required attr package (ftp://oss.sgi.com/projects/xfs/cmd_tars) has to be expanded by the xattr_conf.diff patch. This patch provides the needed attr_copy_action function. With this patch, the config file /etc/xattr.conf defines, which xattr are respected and which xattrs are ignored by file system operations.<BR><BR><b>mv</b><BR><BR>For moving file, we have to differentiate between moving inside a file system and moving from one file system to another.<BR><BR>Moving inside one file system is just a renaming the file system table entry and not touching inodes. Hence moving inside a file system doesn't require xattr support.<BR>Observing this operation with strace shows, that moving the binary myping from the current working directory to the sub folder testdir calls just rename.<BR><BR><pre>$ strace mv myping testdir/<BR><BR>execve("/usr/bin/mv", ["mv", "myping", "testdir/"], [/* 53 vars */]) = 0<BR>...<BR>stat64("testdir/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0<BR>lstat64("myping", {st_mode=S_IFREG|0711, st_size=28992, ...}) = 0<BR>lstat64("testdir/myping", 0xbf97a664)   = -1 ENOENT (No such file or directory)<BR>rename("myping", "testdir/myping")      = 0<BR>...<BR>Process 28411 detached</pre><BR><BR><BR>Moving from one file system to another on a different partition is actually writing the file to the new file system and unlinking the old file. The extended attributes have to be assigned new. As a bonus I'm showing here the calls for libacl and libattr and the permisssion error. The permission error shows, that calling fsetxattr is only sucessful, when the process has the required priviledge. So beside allowing the file system operation binary to transport xattr through /etc/xattr.conf, the binary needs the PCap cap_set_fcap. Here in this example, as a consequence the xattr capability is lost.<BR><BR><BR><pre>$ strace mv myping /var/testdir/<BR><BR>execve("/usr/bin/mv", ["mv", "myping", "/var/testdir/"], [/* 53 vars */]) = 0<BR>...<BR>open("/lib/libacl.so.1", O_RDONLY)      = 3<BR>...<BR>open("/lib/libattr.so.1", O_RDONLY)     = 3<BR>...<BR>stat64("/var/testdir/", {st_mode=S_IFDIR|0755, st_size=1024, ...}) = 0<BR>lstat64("myping", {st_mode=S_IFREG|0711, st_size=28992, ...}) = 0<BR>lstat64("/var/testdir/myping", 0xbfb36824) = -1 ENOENT (No such file or directory)<BR>rename("myping", "/var/testdir/myping") = -1 EXDEV (Invalid cross-device link)<BR>unlink("/var/testdir/myping")           = -1 ENOENT (No such file or directory)<BR>open("myping", O_RDONLY|O_LARGEFILE)    = 3<BR>...<BR>open("/var/testdir/myping", O_WRONLY|O_CREAT|O_EXCL|O_LARGEFILE, 0700) = 4<BR>...<BR>read(3, "&#092;177ELF&#092;1&#092;1&#092;1&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;2&#092;0&#092;3&#092;0&#092;1&#092;0&#092;0&#092;0&#092;340&#092;216"..., 8192) = 8192<BR>write(4, "&#092;177ELF&#092;1&#092;1&#092;1&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;2&#092;0&#092;3&#092;0&#092;1&#092;0&#092;0&#092;0&#092;340&#092;216"..., 8192) = 8192<BR>read(3, "&#092;204&#092;355&#092;2&#092;0&#092;0&#092;201=T&#092;373&#092;4&#092;10&#092;347&#092;3&#092;0&#092;0&#092;17&#092;216&#092;33&#092;n&#092;0&#092;0"..., 8192) = 8192<BR>write(4, "&#092;204&#092;355&#092;2&#092;0&#092;0&#092;201=T&#092;373&#092;4&#092;10&#092;347&#092;3&#092;0&#092;0&#092;17&#092;216&#092;33&#092;n&#092;0&#092;0"..., 8192) = 8192<BR>read(3, "&#092;300&#092;17&#092;204&#092;351&#092;2&#092;0&#092;0P&#092;215E&#092;360Ph&#092;264&#092;342&#092;4&#092;10S&#092;350a&#092;316"..., 8192) = 8192<BR>write(4, "&#092;300&#092;17&#092;204&#092;351&#092;2&#092;0&#092;0P&#092;215E&#092;360Ph&#092;264&#092;342&#092;4&#092;10S&#092;350a&#092;316"..., 8192) = 8192<BR>read(3, "SUM)&#092;0!E&#092;0!EC&#092;0From %s: &#092;0ping: loca"..., 8192) = 4416<BR>write(4, "SUM)&#092;0!E&#092;0!EC&#092;0From %s: &#092;0ping: loca"..., 4416) = 4416<BR>...<BR>flistxattr(3, (nil), 0)                 = 20<BR>flistxattr(3, 0xbfb365d0, 20)           = 20<BR>open("/etc/xattr.conf", O_RDONLY|O_LARGEFILE) = 5<BR>...<BR>fgetxattr(3, "security.capability", 0x0, 0) = 12<BR>fgetxattr(3, "security.capability", "&#092;x01&#092;x00&#092;x00&#092;x01&#092;x00 &#092;x00&#092;x00&#092;x00&#092;x00&#092;x00", 12) = 12<BR>fsetxattr(4, "security.capability", "&#092;x01&#092;x00&#092;x00&#092;x01&#092;x00 &#092;x00&#092;x00&#092;x00&#092;x00&#092;x00", 12, 0) = -1 EPERM (Operation not permitted)<BR>...<BR>unlinkat(AT_FDCWD, "myping", 0)         = 0<BR>...<BR>Process 28422 detached</pre><BR><BR>Without strace we have a nice error message:<BR><BR><pre>mv myping /var/testdir/<BR>mv: setting attribute `security.capability' for `/var/testdir/myping': Operation not permitted</pre><BR><BR><BR><BR><b>cp</b><BR><BR>The cli tool cp provides the option --preserve. With cp --preserve=xattrs the copy operation dublicates also the extended attributes. In contrast to the example above with the nessecary privilege. As we can see, the PCap is copied.<BR><BR><pre>$ strace cp --preserve=xattr myping testdir/<BR><BR>execve("/bin/cp", ["cp", "--preserve=xattr", "myping", "testdir/"], [/* 55 vars */]) = 0<BR>...<BR>open("/lib/libacl.so.1", O_RDONLY)      = 3<BR>...<BR>open("/lib/libattr.so.1", O_RDONLY)     = 3<BR>...<BR>stat64("testdir/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0<BR>stat64("myping", {st_mode=S_IFREG|0711, st_size=28992, ...}) = 0<BR>stat64("testdir/myping", {st_mode=S_IFREG|0711, st_size=28992, ...}) = 0<BR>open("myping", O_RDONLY|O_LARGEFILE)    = 3<BR>...<BR>open("testdir/myping", O_WRONLY|O_TRUNC|O_LARGEFILE) = 4<BR>...<BR>read(3, "&#092;177ELF&#092;1&#092;1&#092;1&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;2&#092;0&#092;3&#092;0&#092;1&#092;0&#092;0&#092;0&#092;340&#092;216"..., 8192) = 8192<BR>write(4, "&#092;177ELF&#092;1&#092;1&#092;1&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;2&#092;0&#092;3&#092;0&#092;1&#092;0&#092;0&#092;0&#092;340&#092;216"..., 8192) = 8192<BR>read(3, "&#092;204&#092;355&#092;2&#092;0&#092;0&#092;201=T&#092;373&#092;4&#092;10&#092;347&#092;3&#092;0&#092;0&#092;17&#092;216&#092;33&#092;n&#092;0&#092;0"..., 8192) = 8192<BR>write(4, "&#092;204&#092;355&#092;2&#092;0&#092;0&#092;201=T&#092;373&#092;4&#092;10&#092;347&#092;3&#092;0&#092;0&#092;17&#092;216&#092;33&#092;n&#092;0&#092;0"..., 8192) = 8192<BR>read(3, "&#092;300&#092;17&#092;204&#092;351&#092;2&#092;0&#092;0P&#092;215E&#092;360Ph&#092;264&#092;342&#092;4&#092;10S&#092;350a&#092;316"..., 8192) = 8192<BR>write(4, "&#092;300&#092;17&#092;204&#092;351&#092;2&#092;0&#092;0P&#092;215E&#092;360Ph&#092;264&#092;342&#092;4&#092;10S&#092;350a&#092;316"..., 8192) = 8192<BR>read(3, "SUM)&#092;0!E&#092;0!EC&#092;0From %s: &#092;0ping: loca"..., 8192) = 4416<BR>write(4, "SUM)&#092;0!E&#092;0!EC&#092;0From %s: &#092;0ping: loca"..., 4416) = 4416<BR>flistxattr(3, (nil), 0)                 = 20<BR>flistxattr(3, 0xbfc78410, 20)           = 20<BR>open("/etc/xattr.conf", O_RDONLY|O_LARGEFILE) = 5<BR>...<BR>fgetxattr(3, "security.capability", 0x0, 0) = 12<BR>fgetxattr(3, "security.capability", "&#092;x01&#092;x00&#092;x00&#092;x01&#092;x00 &#092;x00&#092;x00&#092;x00&#092;x00&#092;x00", 12) = 12<BR>fsetxattr(4, "security.capability", "&#092;x01&#092;x00&#092;x00&#092;x01&#092;x00 &#092;x00&#092;x00&#092;x00&#092;x00&#092;x00", 12, 0) = 0<BR>...<BR>Process 15337 detached</pre></TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="File system operations - Back up and restore with tar">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">File system operations - Back up and restore with tar</TD></TR>
<TR><TD CLASS="tdo">
The back up tool tar up to version 1.20 from http://www.gnu.org/software/tar/ doesn't support extended attributes. Thanks to the external xattr patch, tar supports the saving and restoring of the extended attributes security.selinux, acl.access, acl.default, user.* and trusted.* with the flag --xattr. The patch I provide here adds support for the extended attribute security.capability.</TD></TR>
<TR><TD CLASS="tdp">
When we create the tarball and observe this with strace, we can see, that the PCaps are read and stored:<BR><BR><pre>$ strace tar --xattr -cf tarball myping<BR><BR>execve("/usr/bin/tar", ["tar", "--xattr", "-cf", "tarball", "myping"], [/* 53 vars */]) = 0<BR>...<BR>open("/lib/libacl.so.1", O_RDONLY)      = 3<BR>...<BR>open("/lib/libattr.so.1", O_RDONLY)     = 3<BR>...<BR>open("tarball", O_WRONLY|O_CREAT|O_TRUNC|O_LARGEFILE, 0666) = 3<BR>...<BR>open("myping", O_RDONLY|O_LARGEFILE)    = 4<BR>...<BR>flistxattr(4, 0x8086130, 1024)          = 20<BR>fgetxattr(4, "security.capability", "&#092;x01&#092;x00&#092;x00&#092;x01&#092;x00 &#092;x00&#092;x00&#092;x00&#092;x00&#092;x00", 1024) = 12<BR>...<BR>write(3, "./PaxHeaders.16524/myping&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0"..., 10240) = 10240<BR>read(4, "}]&#092;213&#092;r&#092;350,&#092;6&#092;10&#092;205&#092;311u&#092;7=&#092;370&#092;377&#092;0&#092;0v7RPht&#092;332&#092;4"..., 10240) = 10240<BR>write(3, "}]&#092;213&#092;r&#092;350,&#092;6&#092;10&#092;205&#092;311u&#092;7=&#092;370&#092;377&#092;0&#092;0v7RPht&#092;332&#092;4"..., 10240) = 10240<BR>read(4, "&#092;213&#092;3+E&#092;354&#092;211&#092;3&#092;215&#092;4&#092;200&#092;215&#092;4&#092;200&#092;215&#092;4&#092;200&#092;215&#092;4"..., 10048) = 10048<BR>...<BR>write(3, "&#092;213&#092;3+E&#092;354&#092;211&#092;3&#092;215&#092;4&#092;200&#092;215&#092;4&#092;200&#092;215&#092;4&#092;200&#092;215&#092;4"..., 10240) = 10240<BR>write(3, "&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0"..., 10240) = 10240<BR>...<BR>Process 16524 detached</pre><BR><BR><BR>When we extract the created tarball and observe this with strace, we can see, that the PCaps are restored. For restoring the xattr, tar needs the necessary privilege.<BR><BR><pre>$ strace tar --xattr -xf ../tarball<BR><BR>execve("/bin/tar", ["tar", "--xattr", "-xf", "../tarball"], [/* 55 vars */]) = 0<BR>...<BR>open("/lib/libacl.so.1", O_RDONLY)      = 3<BR>...<BR>open("/lib/libattr.so.1", O_RDONLY)     = 3<BR>...<BR>open("../tarball", O_RDONLY|O_LARGEFILE) = 3<BR>read(3, "./PaxHeaders.16524/myping&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0"..., 10240) = 10240<BR>...<BR>open("myping", O_WRONLY|O_CREAT|O_EXCL|O_LARGEFILE, 0700) = 4<BR>write(4, "&#092;177ELF&#092;1&#092;1&#092;1&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;0&#092;2&#092;0&#092;3&#092;0&#092;1&#092;0&#092;0&#092;0&#092;340&#092;216"..., 8704) = 8704<BR>read(3, "}]&#092;213&#092;r&#092;350,&#092;6&#092;10&#092;205&#092;311u&#092;7=&#092;370&#092;377&#092;0&#092;0v7RPht&#092;332&#092;4"..., 10240) = 10240<BR>write(4, "}]&#092;213&#092;r&#092;350,&#092;6&#092;10&#092;205&#092;311u&#092;7=&#092;370&#092;377&#092;0&#092;0v7RPht&#092;332&#092;4"..., 10240) = 10240<BR>read(3, "&#092;213&#092;3+E&#092;354&#092;211&#092;3&#092;215&#092;4&#092;200&#092;215&#092;4&#092;200&#092;215&#092;4&#092;200&#092;215&#092;4"..., 10240) = 10240<BR>write(4, "&#092;213&#092;3+E&#092;354&#092;211&#092;3&#092;215&#092;4&#092;200&#092;215&#092;4&#092;200&#092;215&#092;4&#092;200&#092;215&#092;4"..., 10048) = 10048<BR>...<BR>chown32("myping", 1000, 100)            = 0<BR>...<BR>setxattr("myping", "security.capability", "&#092;x01&#092;x00&#092;x00&#092;x01&#092;x00 &#092;x00&#092;x00&#092;x00&#092;x00&#092;x00", 12, 0) = 0<BR>chmod("myping", 0711)                   = 0<BR>...<BR>Process 16751 detached</pre></TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="File system operations - back up and restore with rsync">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">File system operations - back up and restore with rsync</TD></TR>
<TR><TD CLASS="tdo">
The back up tool rsync supports since 3.x xattr. Just look for the string xattr in the output of 'rsync --version'.</TD></TR>
<TR><TD CLASS="tdp">
The flag {-X|--xattrs} preseves extended attributes. Executed in the context of root, rsync will copy all namespaces except system.*. Called by an unprivileged user, rsync will only copy the user* namespace.<BR>To sync files with PCaps, the files have to be owned by root and rsync has to be executed as root.<BR><BR><pre>$ strace -f rsync -a --xattrs testdir1/ testdir2/<BR><BR>execve("/usr/bin/rsync", ["rsync", "-a", "--xattrs", "testdir1/", "testdir2/"], [/* 54 vars */]) = 0<BR>...<BR>open("/lib/libacl.so.1", O_RDONLY)      = 3<BR>...<BR>open("/lib/libattr.so.1", O_RDONLY)     = 3<BR>...<BR>getuid32()                              = 0<BR>geteuid32()                             = 0<BR>...<BR>getcwd("/home/chris/pcaps-testdir", 4095) = 26<BR>...<BR>clone(Process 13937 attached<BR>...<BR>[pid 13936] chdir("/home/chris/pcaps-testdir/testdir1") = 0<BR>...<BR>[pid 13936] llistxattr(".", 0x80c8eb8, 1024) = 0<BR>...<BR>[pid 13936] llistxattr("./myping", 0x80c8eb8, 1024) = 44<BR>[pid 13936] lgetxattr("./myping", "security.capability", 0x0, 0) = 12<BR>[pid 13936] lgetxattr("./myping", "security.capability", "&#092;x01&#092;x00&#092;x00&#092;x01&#092;x00 &#092;x00&#092;x00&#092;x00&#092;x00&#092;x00", 12) = 12<BR>...<BR>[pid 13937] chdir("/home/chris/pcaps-testdir/testdir2/") = 0<BR>...<BR>[pid 13937] clone(Process 13938 attached<BR>...<BR>[pid 13936] open("myping", O_RDONLY|O_LARGEFILE) = 3<BR>...<BR>[pid 13938] open("myping", O_RDONLY|O_LARGEFILE) = -1 ENOENT (No such file or directory)<BR>...<BR>[pid 13938] open(".myping.MvDXAT", O_RDWR|O_CREAT|O_EXCL|O_LARGEFILE, 0600) = 1<BR>[pid 13938] fchmod(1, 0700)             = 0<BR>...<BR>[pid 13938] llistxattr(".myping.MvDXAT", 0x80ba538, 1024) = 0<BR>[pid 13938] lsetxattr(".myping.MvDXAT", "security.capability", "&#092;x01&#092;x00&#092;x00&#092;x01&#092;x00 &#092;x00&#092;x00&#092;x00&#092;x00&#092;x00", 12, 0) = 0<BR>...<BR>[pid 13938] chmod(".myping.MvDXAT", 0755) = 0<BR>[pid 13938] rename(".myping.MvDXAT", "myping") = 0<BR>...<BR>...<BR>Process 13938 detached<BR>...<BR>Process 13937 detached<BR>...<BR>Process 13936 detached</pre></TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Examples - Substitution of suid-0 privilege with POSIX Capabilities privilege">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Examples - Substitution of suid-0 privilege with POSIX Capabilities privilege</TD></TR>
<TR><TD CLASS="tdo">
Here we keep sticking to the idea of connecting the needed privileges to the binary. But instead of giving the binary all the privileges the root power consist of, we just grant the needed privileges in form of POSIX Capabilities as File POSIX Capabilities. Following the 'principle of least privilege', we reduce the amount of privileges.</TD></TR>
<TR><TD CLASS="tdp">
There is are reasons for suid-0 binaries to be usable for the unprivileged user. Here we don't doubt this decision, we just reduce the level of power.<BR>To have the binaries just ready to execute with their privileges without expecting them to be PCaps aware, we have to grant the PCaps with the Permitted (p) and Effective (e) Flag.<BR><BR><BR>To find the binaries with suid-0 we use find. Here the result from my installation<BR><BR><pre>$ find {,/usr}/{,s}bin -user root -perm -4000 -exec ls -l {} &#092;;<BR><BR>-rwsr-xr-x 1 root root 26352 Mar  9 03:54 /bin/su<BR>-rws--x--x 1 root root 28992 May  9  2007 /bin/ping<BR>-rwsr-xr-x 1 root root 49120 Mar 31 23:56 /bin/mount<BR>-rwsr-xr-x 1 root root 32208 Mar 31 23:56 /bin/umount<BR>-rwsr-xr-x 1 root root 19836 Mar  8 02:52 /bin/fusermount<BR>-rws--x--x 1 root root 26804 May  9  2007 /bin/ping6<BR>-rwsr-xr-x 1 root root 23344 Mar  9 02:42 /sbin/unix_chkpwd<BR>-r-s--x--x 1 root root 65048 Apr  1 05:09 /sbin/mount.nfs<BR>-rwsr-xr-x 1 root root 38464 Mar  9 03:54 /usr/bin/chage<BR>-rwsr-xr-x 1 root root 29196 Mar  9 03:54 /usr/bin/chfn<BR>-rwsr-xr-x 1 root root 24612 Mar  9 03:54 /usr/bin/chsh<BR>-rws--x--x 1 root root 10480 Dec 13  2006 /usr/bin/crontab<BR>-rwsr-xr-x 1 root root 18152 Mar  9 03:54 /usr/bin/expiry<BR>-rwsr-xr-x 1 root root 42956 Mar  9 03:54 /usr/bin/gpasswd<BR>-rwsr-xr-x 1 root root 22600 Mar  9 03:54 /usr/bin/newgrp<BR>-rwsr-xr-x 1 root root 30176 Mar  9 03:54 /usr/bin/passwd<BR>-rws--x--x 1 root root 14828 Apr 30  2007 /usr/bin/rcp<BR>-rws--x--x 1 root root 10764 Apr 30  2007 /usr/bin/rlogin<BR>-rws--x--x 1 root root 7944 Apr 30  2007 /usr/bin/rsh<BR>-rws--x--x 1 root bin 90400 Feb  6  2006 /usr/bin/sudo<BR>-rws--x--x 1 root bin 16100 Mar  3  2003 /usr/bin/traceroute<BR>-rws--x--x 1 root root 11484 May  9  2007 /usr/bin/traceroute6<BR>-rwsr-xr-x 1 root root 10104 Feb 26 21:40 /usr/bin/kcheckpass<BR>-rwsr-xr-x 1 root root 5412 Mar  8 05:49 /usr/bin/start_kdeinit<BR>-rwsr-xr-x 1 root root 11003 Oct  1  2006 /usr/bin/fileshareset<BR>-rwsr-xr-x 1 root root 5824 Mar  8 05:49 /usr/bin/kgrantpty<BR>-rwsr-xr-x 1 root root 6132 Mar  8 05:49 /usr/bin/kpac_dhcp_helper<BR>-rwsr-x--- 1 root floppy 19076 May  1  2002 /usr/bin/fdmount<BR>-rwsr-xr-x 1 root root 572008 Feb 26 03:52 /usr/bin/kppp<BR>-rwsr-sr-x 1 root mail 65368 Sep 19  2006 /usr/bin/procmail<BR>-rwsr-xr-x 1 root root 1651720 Dec 14 19:42 /usr/bin/Xorg</pre><BR><BR><BR>Out of this list have I substituted for the following binaries the suid-0 bit with PCaps.<BR><BR><pre>ping - CAP_NET_RAW (13)<BR>traceroute - CAP_NET_RAW (13)<BR>chsh - CAP_CHOWN (0), CAP_DAC_READ_SEARCH (2), CAP_FSETID (4), CAP_SETUID (7)<BR>chfn - CAP_CHOWN (0), CAP_DAC_READ_SEARCH (2), CAP_FSETID (4), CAP_SETUID (7)<BR>chage - CAP_DAC_READ_SEARCH (2)<BR>passwd - CAP_CHOWN (0), CAP_DAC_OVERRIDE (1), CAP_FOWNER (3)<BR>unix_chkpwd - CAP_DAC_OVERRIDE (1)<BR>mount - CAP_DAC_OVERRIDE (1), CAP_SYS_ADMIN (21)<BR>umount - CAP_DAC_OVERRIDE (1), CAP_SYS_ADMIN (21)</pre><BR><BR><BR>First you have to remove the suid-0 bit<BR><BR><pre>sudo chmod u-s /usr/bin/chsh</pre><BR><BR>then grant the necessary PCaps<BR><BR><pre>sudo setcap 0,2,4,7=ep /usr/bin/chsh</pre><BR><BR>and at last test the binary.<BR><BR>I provide the conversion tool pcaps4suid0 to do conversion and reversion for suid0 to PCaps and back.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Examples - Server running as a distinct unprivileged user - Apache">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Examples - Server running as a distinct unprivileged user - Apache</TD></TR>
<TR><TD CLASS="tdo">
Server software is usually executed as root. It might degrade itself to an unprivileged user, when the privileges the root power consist of are not necessary anymore or only a few privileges are needed further. But as so many suid-0 bit software these server software usually needs only a fraction of the privileges the root provides.</TD></TR>
<TR><TD CLASS="tdp">
The typical server software opens one or more privileged ports, accesses his files in his directories and might handle files of local users (might not be complete). So there is no need to load modules, change system time or kill processes of other users.<BR>To protect the process and files of the server from other users, the server will run with his own user and group.<BR><BR>Apache is started with root privilege to bind itself to the privileged port 80 and 443 and open its usually only root owned config file, certificate, log files and pid file.<BR>I choose for the apache httpd daemon the newly created user id and group id apache. I will change the installation and configuration of apache to start and run as user:group apache:apache.<BR><BR>This changes the configuration to be able to start apache as an unprivileged user and run apache as user:group apache:apache.<BR><BR><BR>First we add user apache and group apache to the system<BR><BR><pre>$<BR>$ sudo groupadd apache<BR>$ sudo useradd -g apache -d / apache<BR>$</pre><BR><BR><BR>Than we make sure apache stays apache:apache by changing the User and Group directive in the configuration file /etc/httpd/httpd.conf<BR><BR><pre>$ sudo sed -i -e "{s|^&#092;(User&#092;).*|&#092;1 apache|; s|^&#092;(Group&#092;) .*|&#092;1 apache|}" /etc/httpd/httpd.conf</pre><BR><BR>If we like to have written a pid file, we create the private directory httpd under /var/run and adjust the reference in the httpd.conf.<BR><BR><pre>$<BR>$ sudo mkdir /var/run/httpd<BR>$ sudo sed -i "s|&#092;(^PidFile&#092;).*|&#092;1 /var/run/httpd|" /etc/httpd/httpd.conf<BR>$</pre><BR><BR><BR>Now we change ownership to apacha:apache of various directories and its content belonging to the httpd server<BR><BR><pre>$<BR>$ sudo chown -R apache:apache /var/run/httpd/<BR>$ sudo chown -R apache:apache /etc/httpd/<BR>$ sudo chown -R apache:apache /var/log/httpd/<BR>$ sudo chown -R apache:apache /PATH/TO/YOUR/HTTPD-DOCDIR<BR>$</pre><BR><BR><BR>To ensure, that only the file owner apache or root may start the httpd binary, we change the permissions and ownership<BR><BR><pre>$<BR>$ ls -l /usr/sbin/httpd<BR>-rwxr-xr-x 1 root root 332996 Feb 14 22:39 /usr/sbin/httpd<BR>$ sudo chown apache:apache /usr/sbin/httpd<BR>$ sudo chmod g-x,o-x /usr/sbin/httpd<BR>$ ls -l /usr/sbin/httpd<BR>-rwxr--r-- 1 apache apache 332996 Feb 14 22:39 /usr/sbin/httpd/<BR>$</pre><BR><BR><BR>Because the apache server doesn't need now any privileges accept for opening and binding to privileged ports we just have to grant CAP_NET_BIND_SERVICE to the httpd binary. Assuming, that the httpd binary can't populate its Effective PCaps Set, we grant beside the Permitted Flag (p) also the Effective Flag (e) for the PCap.<BR><BR><pre>$ sudo setcap cap_net_bind_service=ep /usr/sbin/httpd</pre><BR><BR><BR>For not messing up the file permissions and to prevent excessive privilege granting, root shall start the httpd daemon as user apache with something like<BR><BR><pre>$ su -c /usr/sbin/httpd apache</pre><BR><BR><BR>As an unprivileged user you may, if your sudo configuration allows this, start apache just by typing<BR><BR><pre>$ sudo -u apache /usr/sbin/httpd</pre><BR><BR><BR>See how its running<BR><BR><pre>$<BR>$ pidof httpd<BR>15259 15258 15257 15256<BR>$<BR>$ ps -o cmd,pid,ppid,stime,time,euser,ruser -H f -U apache -u apache<BR>CMD                           PID  PPID STIME     TIME EUSER    RUSER<BR>/usr/sbin/httpd             15256     1 09:55 00:00:00 apache   apache<BR> &#092;_ /usr/sbin/httpd         15257 15256 09:55 00:00:00 apache   apache<BR> &#092;_ /usr/sbin/httpd         15258 15256 09:55 00:00:00 apache   apache<BR> &#092;_ /usr/sbin/httpd         15259 15256 09:55 00:00:00 apache   apache<BR>$</pre><BR><BR><BR>An other way to ensure, that httpd runs only as (effective user) apache is granting the suid-0 bit. In the combination with the execute right only for the owner, still no other unprivileged user may start this binary.<BR><BR><pre>$ sudo chmod u+s /usr/sbin/httpd</pre><BR><BR><BR>We simulate a root call per sudo and check again how it is running with euser and ruser. The real user stays root but as intended by the suid-0 bit the effective user changes to apache<BR><BR><pre>$<BR>$ sudo /usr/sbin/httpd<BR>chris@apollo ~ $ ps -o cmd,pid,ppid,stime,time,euser,ruser -H f -U apache -u apache<BR>CMD                           PID  PPID STIME     TIME EUSER    RUSER<BR>/usr/sbin/httpd             15320     1 11:37 00:00:00 apache   root<BR> &#092;_ /usr/sbin/httpd         15321 15320 11:37 00:00:00 apache   root<BR> &#092;_ /usr/sbin/httpd         15322 15320 11:37 00:00:00 apache   root<BR> &#092;_ /usr/sbin/httpd         15323 15320 11:37 00:00:00 apache   root<BR>$</pre><BR><BR><BR>To push it a little further, if we like to allow members of the apache group to start the httpd daemon, we first add this user to the group and change the permission accordingly to allow group members to execute the binary. Now members of the group apache may start the daemon. Non members are still not capable of starting the daemon. Here we use also the suid-0 bit to ensure, that the effective user of the httpd processes is apache.<BR><BR><pre>$<BR>$ ls -l /usr/sbin/httpd<BR>-rwsr--r-- 1 apache apache 332996 Feb 14 22:39 /usr/sbin/httpd<BR>$ /usr/sbin/httpd<BR>bash: /usr/sbin/httpd: Permission denied<BR>$<BR>$ id<BR>uid=1000(chris) gid=100(users) groups=100(users)<BR>$<BR>$ sudo usermod -a -G apache chris<BR>$ sudo chmod g+x /usr/sbin/httpd<BR>$ sudo su - chris<BR>$ id<BR>uid=1000(chris) gid=100(users) groups=60(apache),100(users)<BR>$<BR>$ /usr/sbin/httpd<BR>$ ps -o cmd,pid,ppid,stime,time,euser,ruser -H f -U apache -u apache<BR>CMD                           PID  PPID STIME     TIME EUSER    RUSER<BR>/usr/sbin/httpd             15490     1 12:00 00:00:00 apache   chris<BR> &#092;_ /usr/sbin/httpd         15491 15490 12:00 00:00:00 apache   chris<BR> &#092;_ /usr/sbin/httpd         15492 15490 12:00 00:00:00 apache   chris<BR> &#092;_ /usr/sbin/httpd         15493 15490 12:00 00:00:00 apache   chris<BR>$</pre><BR><BR><BR>I provide the conversion tool pcaps4server to do conversion and reversion for the apache daemon to PCaps and back.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Examples - Server running as a distinct unprivileged user - Bind">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Examples - Server running as a distinct unprivileged user - Bind</TD></TR>
<TR><TD CLASS="tdo">
The name server bind provides name resolution to network clients. Instead of running as root, this daemon will run in the context of an unprivileged user.</TD></TR>
<TR><TD CLASS="tdp">
We will expand the level of privilege just to open and bind itself to privileged ports. Privileged ports are ports up to 1024.<BR><BR><BR>Here we choose as name for the user and group bind. First we have to add the user and the group<BR><pre>$<BR>$ sudo groupadd bind<BR>$ sudo useradd -g bind -d / bind<BR>$</pre><BR><BR><BR>Then we change the ownership of the directories and files belonging to the daemon.<BR><pre>$<BR>$ sudo chown -R bind:bind /var/run/named<BR>$ sudo chown -R bind:bind /var/named<BR>$ sudo chown bind:bind /etc/namend.conf<BR>$ sudo chown bind:bind /etc/rndc.key<BR>$</pre><BR><BR><BR>We make sure, that only the file owner bind (and root per definition) is allowed to start the daemon.<BR><pre>$<BR>$ ls -l /usr/sbin/named<BR>-rwxr-xr-x 1 root root 338920 Apr 14 00:07 /usr/sbin/named*<BR>$ sudo chown bind:bind /usr/sbin/named<BR>$ sudo chmod g-x,o-x /usr/sbin/named<BR>ls -l /usr/sbin/named<BR>-rwxr--r-- 1 bind bind 338920 Apr 14 00:07 /usr/sbin/named<BR>$</pre><BR><BR><BR>By not running as the privileged user root the binary named now misses the needed privilege of opening and binding to privileged ports. So we grant the CAP_NET_BIND PCap.<BR><pre>$ sudo setcap cap_net_bind_service=ep /usr/sbin/named</pre><BR><BR><BR>To keep the installation clean and to prevent granting an excessive privilege level root shall execute named by<BR><pre>$ su -c /usr/sbin/named bind</pre><BR><BR><BR>If an unprivileged user is allowed through the configuration of sudo, he may execute<BR><pre>$ sudo -u bind /usr/sbin/namend</pre><BR><BR><BR>Instead of specifying the user we may also use the suid-bit and the effective user will be bind<BR><pre>$ sudo chmod u+s /usr/sbin/namend</pre><BR><BR><BR>With named we also may populate the group bind by user, who are allowed to start named.<BR><pre>$<BR>$ ls -l /usr/sbin/named<BR>-rwsr--r-- 1 bind bind 338920 Apr 14 00:07 /usr/sbin/named*<BR>$ /usr/sbin/named<BR>bash: /usr/sbin/named: Permission denied<BR>$ id<BR>uid=1000(chris) gid=100(users) groups=100(users)<BR>$<BR>$ sudo usermod -a -G bind chris<BR>$ sudo chmod g+x /usr/sbin/named<BR> $ ls -l /usr/sbin/named<BR>-rwsr-xr-- 1 bind bind 338920 2008-04-14 00:07 /usr/sbin/named<BR>$<BR>$ sudo su - chris<BR>$ id<BR>uid=1000(chris) gid=100(users) groups=62(bind),100(users)<BR>$ /usr/sbin/named<BR>$ ps -o cmd,pid,ppid,stime,time,euser,ruser -H f -U bind -u bind<BR>CMD                           PID  PPID STIME     TIME EUSER    RUSER<BR>/usr/sbin/named             19354     1 14:09 00:00:00 bind     chris<BR>$</pre><BR><BR><BR>The pcaps4server tool also covers bind/named.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Examples - Server running as a distinct unprivileged user - Cupsd">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Examples - Server running as a distinct unprivileged user - Cupsd</TD></TR>
<TR><TD CLASS="tdp">
Reducing the privilege level of the common unix printing system daemon follows the same principle. We create a special user and group which we will call cupsd. We will adjust the ownership of files and directories. And we will grant the needed privileges as PCaps.<BR><BR>We create the user cupsd and the group cupsd<BR><pre>$<BR>$ sudo groupadd cupsd<BR>$ sudo useradd -g cupsd -d / cupsd<BR>$</pre><BR><BR><BR>We make sure, that cupsd will stay with his uid and gid.<BR><pre>$ sudo sed -i -e "{s|^&#092;(User&#092;).*|&#092;1 cupsd|; s|^&#092;(Group&#092;) .*|&#092;1 cupsd|}" /etc/cups/cupsd.conf</pre><BR><BR><BR>We change the ownership to cupsd:cupsd of various directories and its content<BR><pre>$<BR>$ sudo chown -R cupsd:cupsd /etc/cups<BR>$ sudo chown -R cupsd:cupsd /var/cache/cups<BR>$ sudo chown -R cupsd:cupsd /var/log/cups<BR>$ sudo chown -R cupsd:cupsd /var/run/cups<BR>$ sudo chown -R cupsd:cupsd /var/spool/cups<BR>$</pre><BR><BR><BR>To ensure, that only the file owner bind or root may start the cupsd binary, we change the permissions and ownership<BR><pre>$<BR>$ ls -l /usr/sbin/cupsd<BR>-rwxr-xr-x 1 root root 296800 Apr 30 14:37 /usr/sbin/cupsd*<BR>$ sudo chown cupsd:cupsd /usr/sbin/cupsd<BR>$ sudo chmod g-x,o-x /usr/sbin/cupsd<BR>$ ls -l /usr/sbin/cupsd<BR>-rwxr--r-- 1 cupsd cupsd 296800 Apr 30 14:37 /usr/sbin/cupsd<BR>$</pre><BR><BR><BR>So all cupsd needs is the privilege to open and bind to privileged ports<BR><pre>$ sudo setcap cap_net_bind_service=ep /usr/sbin/cupsd</pre><BR><BR><BR>To prevent messing up ownership and an excessive privilege level root, shall start the cupsd daemon like<BR><pre>$ su -c /usr/sbin/cupsd cupsd</pre><BR><BR><BR>If allowed by the sudo configuration, an unprivileged user may start cupsd by<BR><pre>$ sudo -u cupsd /usr/sbin/cupsd</pre><BR><BR><BR>Instead of specifying the user we may also use the suid-bit and the effective user will be cupsd<BR><pre>$ sudo chmod u+s /usr/sbin/cupsd</pre><BR><BR><BR>To allow unprivileged user the execution of cupsd they might be added to the group cupsd. We adapt the file system configuration of cupsd to ensure, that the effective user will be cupsd.<BR><pre>$<BR>$ ls -l /usr/sbin/cupsd<BR>-rwsr--r-- 1 cupsd cupsd 296800 Apr 30 14:37 /usr/sbin/cupsd*<BR>$ /usr/sbin/cupsd<BR>bash: /usr/sbin/cupsd: Permission denied<BR>$ id<BR>uid=1000(chris) gid=100(users) groups=100(users)<BR>$<BR>$ sudo usermod -a -G cupsd chris<BR>$ sudo chmod g+x /usr/sbin/cupsd<BR>$ ls -l /usr/sbin/cupsd<BR>-rwsr-xr-- 1 cupsd cupsd 296800 Apr 30 14:37 /usr/sbin/cupsd*<BR>$<BR>$ sudo su - chris<BR>$ id<BR>uid=1000(chris) gid=100(users) groups=64(cupsd),100(users)<BR>$ /usr/sbin/cupsd<BR>$ ps -o cmd,pid,ppid,stime,time,euser,ruser -H f -U cupsd -u cupsd<BR>CMD                           PID  PPID STIME     TIME EUSER    RUSER<BR>/usr/sbin/cupsd             14346     1 15:46 00:00:00 cupsd    chris<BR>$</pre><BR><BR><BR>I provide the conversion tool pcaps4server to do conversion and reversion for the cupsd daemon to PCaps and back.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Examples - Server running as a distinct unprivileged user - DHCPD">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Examples - Server running as a distinct unprivileged user - DHCPD</TD></TR>
<TR><TD CLASS="tdo">
We are changing the set up and configuration of the Dynamic Host Configuration Protocol Server to run with the just needed privileges. The Dynamic Host Configuration  Protocol allows hosts on a TCP/IP network to request and be assigned IP addresses, and also to discover information about the network to which they are attached.</TD></TR>
<TR><TD CLASS="tdp">
DHCPD requires CAP_NET_BIND_SERVICE and CAP_NET_RAW as PCaps. As the DHCPD is not PCaps aware, we provide legacy support by assigning the needed PCaps beside the Permitted (p) Flag also the Effective (e) Flag. The private user and group will be called dhcpd.<BR><BR>We create the user dhcpd and the group dhcpd<BR><pre>$<BR>$ sudo groupadd dhcpd<BR>$ sudo useradd -g dhcpd -d / dhcpd<BR>$</pre><BR><BR><BR>To be able to write his pid file, we create a private directory, which will be owned by dhcpd:dhcpd<BR><pre>$ sudo mkdir /var/run/dhcpd</pre><BR><BR><BR>We adjust the config file accordingly to use the new pid directory<BR><pre>$ sudo sed -i 's|^&#092;(pid-file-name&#092;).*|&#092;1 "/var/run/dhcpd/dhcpd.pid"|' /etc/dhcpd.conf</pre><BR><BR><BR><BR>We change ownership to dhcpd:dhcpd of various files, directories and its content<BR><pre>$<BR>$ sudo chown dhcpd:dhcpd /etc/dhcpd.conf<BR>$ sudo chown dhcpd:dhcpd /var/run/dhcpd<BR>$ sudo chown -R dhcpd:dhcpd /var/state/dhcp/<BR>$</pre><BR><BR><BR><BR>The dhcpd binary shall only be executable by the file owner dhcpd or root. We change the permissions and ownership accordingly.<BR><pre>$<BR>$ ls -l /usr/sbin/dhcpd<BR>-rwxr-xr-x 1 dhcpd dhcpd 507648 Apr  9 04:16 /usr/sbin/dhcpd*<BR>$ sudo chown dhcpd:dhcpd /usr/sbin/dhcpd<BR>$ sudo chmod g-x,o-x /usr/sbin/dhcpd<BR>chris@apollo ~ $ ls -l /usr/sbin/dhcpd<BR>-rwxr--r-- 1 dhcpd dhcpd 507648 Apr  9 04:16 /usr/sbin/dhcpd*<BR>$</pre><BR><BR><BR>We grant the needed PCaps to the dhcpd binary<BR><pre>sudo setcap cap_net_bind_service,cap_net_raw=ep /usr/sbin/dhcpd</pre><BR><BR><BR>When started out of the context of root, as in start scripts, dhcpd shall be called to prevent messing up of file ownership and an excessive privilege level by<BR><pre>$ su -c /usr/sbin/dhcpd dhcpd</pre><BR><BR><BR>If the system security policy and therefore the sudo configuration allows it, an unprivileged user may start the dhcpd daemon by typing<BR><pre>$ sudo -u dhcpd /usr/sbin/dhcpd</pre><BR><BR><BR>By using the suid-bit, the user doesn't have to be specified. The effective user will change to the file owner.<BR><pre>$ sudo chmod u+s /usr/sbin/dhcpd</pre><BR><BR><BR>By using the technique of group membership and the right to execute the binary for group members and the suid-bit technique, these group members may also execute dhcpd<BR><pre>$<BR>$<BR>$ ls -l /usr/sbin/dhcpd<BR>-rwsr--r-- 1 dhcpd dhcpd 507648 Apr  9 04:16 /usr/sbin/dhcpd*<BR>$ /usr/sbin/dhcpd<BR>bash: /usr/sbin/dhcpd: Permission denied<BR>$ id<BR>uid=1000(chris) gid=100(users) groups=100(users)<BR>$<BR>$ sudo usermod -a -G dhcpd chris<BR>$ sudo chmod g+x /usr/sbin/dhcpd<BR>$ ls -l /usr/sbin/dhcpd<BR>-rwsr-xr-- 1 dhcpd dhcpd 507648 Apr  9 04:16 /usr/sbin/dhcpd*<BR>$<BR>$ sudo su - chris<BR>$ id<BR>uid=1000(chris) gid=100(users) groups=63(dhcpd),100(users)<BR>$ /usr/sbin/dhcpd<BR>Internet Systems Consortium DHCP Server V3.0.6<BR>Copyright 2004-2007 Internet Systems Consortium.<BR>All rights reserved.<BR>For info, please visit http://www.isc.org/sw/dhcp/<BR>Wrote 25 leases to leases file.<BR>Listening on LPF/eth1/00:0b:5d:29:73:3b/192.168.4/24<BR>Sending on   LPF/eth1/00:0b:5d:29:73:3b/192.168.4/24<BR>Sending on   Socket/fallback/fallback-net<BR>$<BR>$ ps -o cmd,pid,ppid,stime,time,euser,ruser -H f -U dhcpd -u dhcpd<BR>CMD                           PID  PPID STIME     TIME EUSER    RUSER<BR>/usr/sbin/dhcpd             32674     1 09:59 00:00:00 dhcpd    chris<BR>$</pre><BR><BR><BR>The pcaps4server tool also covers dhcpd.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Examples - Server running as a distinct unprivileged user - SAMBA">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Examples - Server running as a distinct unprivileged user - SAMBA</TD></TR>
<TR><TD CLASS="tdo">
We will following here also the principle of least privilege to reduce the amount of privileges of the SMB/CIFS fileserver SAMBA.</TD></TR>
<TR><TD CLASS="tdp">
Of the SAMBA package SMBD requires CAP_NET_BIND_SERVICE, CAP_SYS_RESOURCE and CAP_DAC_OVERRIDE as PCaps. NMBD just requires CAP_NET_BIND_SERVICE. Here we provide also legacy support, because we grant beside the Permitted (p) Flag also the Effective (e) Flag to the PCaps. The user and private group will be called samba.<BR><BR><BR>We start by creating the privat group samba and the user samba, whose primary and only group is samba<BR><pre>$<BR>$ sudo groupadd samba<BR>$ sudo useradd -g samba -d / samba<BR>$</pre><BR><BR><BR>To be able to write his pid files, we create a private directory, which will be owned his user:group<BR><pre>$ sudo mkdir /var/run/samba</pre><BR><BR><BR>We adjust the configuration file accordingly to use the new pid directory<BR><pre>$ sudo sed -i 's|&#092;(pid directory =&#092;).*|&#092;1 "/var/run/samba"|' /etc/samba/smb.conf</pre><BR><BR><BR>To be able to write his log file, we create a private directory, which will be owned his user:group<BR><pre>$ sudo mkdir /var/log/samba</pre><BR><BR><BR>We adjust the config file accordingly to use the new log directory. Adjust it to your log scheme like for example /var/log/samba/samba.%m .<BR><pre>$ sudo sed -i 's|&#092;(log file =&#092;).*|&#092;1 "/var/log/samba/samba.log"|' /etc/samba/smb.conf</pre><BR><BR><BR>We adjust the ownership of various directories and file, which are belonging to SAMBA<BR><pre>$<BR>$ sudo chown -R samba:samba /etc/samba<BR>$ sudo chown -R samba:samba /var/cache/samba<BR>$ sudo chown -R samba:samba /var/log/samba<BR>$ sudo chown -R samba:samba /var/run/samba<BR>$</pre><BR><BR><BR>Only the file owner samba shall be allowed to start the daemon smbd and nmbd. We change the mode bits and ownership.<BR><pre>$<BR>$ ls -l /usr/sbin/nmbd /usr/sbin/smbd<BR>-rwxr-xr-x 1 root root 1021704 Mar 15 21:52 /usr/sbin/nmbd*<BR>-rwxr-xr-x 1 root root 3677972 Mar 15 21:52 /usr/sbin/smbd*<BR>$ sudo chown samba:samba /usr/sbin/nmbd /usr/sbin/smbd<BR>$ sudo chmod g-x,o-x /usr/sbin/nmbd /usr/sbin/smbd<BR>$ ls -l /usr/sbin/nmbd /usr/sbin/smbd<BR>-rwxr--r-- 1 samba samba 1021704 Mar 15 21:52 /usr/sbin/nmbd*<BR>-rwxr--r-- 1 samba samba 3677972 Mar 15 21:52 /usr/sbin/smbd*<BR>$</pre><BR><BR><BR>We grant the needed privileges as PCaps to the Permitted and Effective Set<BR><pre>$<BR>$ sudo setcap cap_net_bind_service=ep /usr/sbin/nmbd<BR>$ sudo setcap cap_net_bind_service,cap_sys_resource,cap_dac_override=ep /usr/sbin/smbd<BR>$</pre><BR><BR><BR>Out of a root context the daemons should be started as<BR><pre>$<BR>$su -c /usr/sbin/nmbd samba<BR>$su -c /usr/sbin/smbd samba<BR>$</pre><BR><BR><BR>Per sudo, if the configuration allows it, an unprivileged user might start it by using<BR><pre>$<BR>$ sudo -u samba /usr/sbin/nmbd<BR>$ sudo -u samba /usr/sbin/smbd<BR>$</pre><BR><BR><BR>By using the suid-bit technique we ensure that the effective user will be the file owner without specifying this user<BR><pre>$ sudo chmod u+s /usr/sbin/nmbd /usr/sbin/smbd</pre><BR><BR><BR>If we want other users to allow the SAMBA daemons, they might be added to the samba group, which will also granted the execute bit. With the suid-bit we assure that the effective user will still be samba.<BR><pre>$<BR>$ ls -l /usr/sbin/nmbd /usr/sbin/smbd<BR>-rwsr--r-- 1 samba samba 1021704 Mar 15 21:52 /usr/sbin/nmbd*<BR>-rwsr--r-- 1 samba samba 3677972 Mar 15 21:52 /usr/sbin/smbd*<BR>$ /usr/sbin/nmbd; /usr/sbin/smbd<BR>bash: /usr/sbin/nmbd: Permission denied<BR>bash: /usr/sbin/smbd: Permission denied<BR>$ id<BR>uid=1000(chris) gid=100(users) groups=100(users)<BR>$<BR>$ sudo usermod -a -G samba chris<BR>$ sudo chmod g+x /usr/sbin/nmbd /usr/sbin/smbd<BR>$ ls -l /usr/sbin/nmbd /usr/sbin/smbd<BR>-rwxr-xr-- 1 samba samba 1021704 Mar 15 21:52 /usr/sbin/nmbd*<BR>-rwxr-xr-- 1 samba samba 3677972 Mar 15 21:52 /usr/sbin/smbd*<BR>$<BR>$ sudo su - chris<BR>$ id<BR>uid=1000(chris) gid=100(users) groups=61(samba),100(users)<BR>$ /usr/sbin/nmbd; /usr/sbin/smbd<BR>$<BR>$ /usr/sbin/nmbd; /usr/sbin/smbd<BR>chris@apollo ~ $ ps -o cmd,pid,ppid,stime,time,euser,ruser -H f -U samba -u samba<BR>CMD                           PID  PPID STIME     TIME EUSER    RUSER<BR>/usr/sbin/smbd                786     1 13:23 00:00:00 samba    samba<BR> &#092;_ /usr/sbin/smbd            787   786 13:23 00:00:00 samba    samba<BR>/usr/sbin/nmbd                783     1 13:23 00:00:00 samba    chris<BR> &#092;_ /usr/sbin/nmbd            784   783 13:23 00:00:00 samba    chris<BR>$</pre><BR><BR><BR>The pcaps4server tool also covers SAMBA.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Intro">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Intro</TD></TR>
<TR><TD CLASS="tdo">
POSIX Capability Inheritance allows to control who might successful execute a binary, when this binary needs for successful execution a privilege level above of an unprivileged user. Only when both the calling process - and a logged in user is system intern a process - and the called binary have the - for successful execution necessary - PCaps in their Inheritance Set, this PCaps will get the Permitted (p) Flag for the resulting process.</TD></TR>
<TR><TD CLASS="tdp">
Up to here all examples were using the Permitted (p) and Effective (e) Flag. Permitted Flag signifies "you can use it - it is in your toolbox". Effective Flag says "you are using it - you have taken it out of your toolbox, it is in your hand". The Permitted (P) Set, the sum of all PCaps with the Permitted (p) Flag is also called the Minimal Forced Set. Independent of the calling process, the resulting process will have the PCaps of the File Permitted Set in his Process Permitted Set (limited by the System Upper Limit X /proc/sys/kernel/cap-bound or since 2.6.25 by the Inherited Per-Process Upper Limit X). The Effective Flag is only granted to binaries, who are not capable to populate their Effective Set on their own. Not PCaps aware applications are seen as legacy applications and their support through the use of the File Effective Set is called legacy support. So the use of the Effective Flag is actually legacy support.<BR>The Inheritance (i) Flag stays in contrast to the Permitted (p) Flag. Instead of granting the needed PCap the Permitted (p) Flag we might grant the Inheritance (i) Flag.<BR><BR>To illustrate this, we use our beloved ping. Instead running in the context of root as suid-0, and so be able to load modules, change the system time and delete everyones file, we changed the file configuration by eliminating the suid-0 and by granting the needed PCap CAP_NET_RAW the Permitted (p) Flag. Because ping is PCaps unaware we also granted CAP_NET_RAW the Effective (e) Flag.<BR><BR>Just for repetition - the whole story<BR><pre>$<BR>$ ls -l /bin/ping<BR>-rws--x--x 1 root root 28992 2007-05-09 19:59 /bin/ping*<BR>$ ping -c 1 localhost<BR>PING localhost (127.0.0.1) 56(84) bytes of data.<BR>64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.108 ms<BR><BR>--- localhost ping statistics ---<BR>1 packets transmitted, 1 received, 0% packet loss, time 0ms<BR>rtt min/avg/max/mdev = 0.108/0.108/0.108/0.000 ms<BR>$<BR>$ sudo chmod u-s /bin/ping<BR>$ ls -l /bin/ping<BR>-rwx--x--x 1 root root 28992 2007-05-09 19:59 /bin/ping*<BR>$ ping -c 1 localhost<BR>ping: icmp open socket: Operation not permitted<BR>$<BR>$ sudo setcap cap_net_raw=ep /bin/ping<BR>$ getcap /bin/ping<BR>/bin/ping = cap_net_raw+ep<BR>$ ping -c 1 localhost<BR>PING localhost (127.0.0.1) 56(84) bytes of data.<BR>64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.120 ms<BR><BR>--- localhost ping statistics ---<BR>1 packets transmitted, 1 received, 0% packet loss, time 0ms<BR>rtt min/avg/max/mdev = 0.120/0.120/0.120/0.000 ms<BR>$</pre><BR><BR>Now we have a binary which might be successfully executed by everyone (as before with the suid-0 but with less privilege - but that's not the point here).<BR><BR>But for example our security policy might say, only certain users are allowed to execute applications with the privilege level of the PCap CAP_NET_RAW. These application in question needs for successful execution the CAP_NET_RAW PCap. We grant for the user and for the application this PCap CAP_NET_RAW a special flag, the Inheritable (i) Flag. For the calling process, here the logged in user, having a PCap in his Inheritable Set (pI) means to say, "I have a PCap (in my Inheritable Set), that may go into your Permitted Set (pP'), if you are allowed to receive it". For the called application, having a PCap in his Inheritable Set (fI) is like stating, "I have a PCap (in my Inheritable Set), that may go into my Process Permitted Set (pP') if you, who executes me, have the same PCap in your Process Inheritable Set (pI)". So caller and callee, both of them, have to have the PCap in question in their Inheritable Set, for this PCap to be in the Process Permitted Set (pP') of the new process.<BR><BR>We change the PCap configuration of ping, to expect be called by a process, who is allowed to execute an application with this PCap.<BR><pre>$<BR>$ ls -l /bin/ping<BR>-rwx--x--x 1 root root 28992 2007-05-09 19:59 /bin/ping<BR>$ getcap /bin/ping<BR>/bin/ping = cap_net_raw+ep<BR>$ sudo setcap cap_net_raw=ei /bin/ping<BR>$ getcap /bin/ping<BR>/bin/ping = cap_net_raw+ei<BR>$</pre><BR><BR>Now we check the PCaps of our logged in session with getpcaps, its as expected empty<BR><pre>$<BR>$ /sbin/getpcaps $$<BR>Capabilities for `2545': =<BR>$</pre><BR><BR>And executing ping fails<BR><pre>$<BR>$ ping -c 1 localhost<BR>ping: icmp open socket: Operation not permitted<BR>$</pre><BR><BR>Now with a proper configured pam based log in process, our logged in process gains the necessary PCap in his Inheritable Set<BR><pre>$<BR>$ grep chris /etc/security/capability.conf<BR>13    chris<BR>$<BR>$ su - chris<BR>Password:<BR>$<BR>$ getpcaps $$<BR>Capabilities for `3610': = cap_net_raw+i<BR>$<BR>$ ping -c 1 localhost<BR>PING localhost (127.0.0.1) 56(84) bytes of data.<BR>64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.123 ms<BR><BR>--- localhost ping statistics ---<BR>1 packets transmitted, 1 received, 0% packet loss, time 0ms<BR>rtt min/avg/max/mdev = 0.123/0.123/0.123/0.000 ms<BR>$</pre><BR><BR>Looking at the appropriate line of the Capability Rules, we see how the Process Permitted Set (pP') of the new process is influenced by the Inheritable Sets. The Intersection of the Caller Process Inheritable Set (pI) and the Called File Inheritable Set (fI) populate (also) the new Process Permitted Set (pP').<BR><pre>2)  pP' = (X & fP) | (pI & fI)</pre><BR><BR><BR>So instead of just granting the needed PCap the Permitted Flag and so allow every process (and user) to execute this application successful, we can create a link between a process/user and an application through the Inheritable Set. Only matching PCaps will go into the Permitted Set of the new process and only by this the application will be executed successful.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Installing the bits">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Installing the bits</TD></TR>
<TR><TD CLASS="tdp">
To be able to use PCaps, we have had already to install the libcap package. This package also installs since version 2.09 the needed PAM Module pam_cap.so into /lib/security and comes with an example configuration file capability.conf, which has to go into /etc/security.<BR><pre>$<BR>$ tar xjf libcap-2.09<BR>$ cd libcap-2.09<BR>$ make<BR>$ sudo make install<BR>$ sudo mkdir /etc/security<BR>$ sudo cp pam_cap/capability.conf /etc/security<BR>$ cd progs<BR>$ ./quicktest<BR>$</pre><BR><BR>The configuration file /etc/security/capability.conf tells the pam_cap.so PAM Module which PCaps a user may get in his Process Inheritable Set.<BR>You may name the PCaps by their name or by their number. Just have a look at /usr/include/linux/capability.h .<BR>Example of capability.h for the ping exercise<BR><pre>$<BR>$ cat /etc/security/capability.conf<BR>#<BR># /etc/security/capability.conf<BR>#<BR># this is a sample capability file (to be used in conjunction with<BR># the pam_cap.so module)<BR>#<BR># In order to use this module, it must have been linked with libcap<BR># and thus you'll know about Linux's capability support.<BR># [If you don't know about libcap, the sources for it are here:<BR>#<BR>#   http://linux.kernel.org/pub/linux/libs/security/linux-privs/<BR>#<BR># .]<BR>#<BR># Here are some sample lines (remove the preceding '#' if you want to<BR># use them<BR><BR>## user 'morgan' gets the CAP_SETFCAP inheritable capability<BR>#cap_setfcap        morgan<BR><BR><BR>## user 'luser' just inherits two capabilities (CAP_NET_RAW and CAP_FOWNER)<BR># cap_net_raw,cap_fowner	luser<BR><BR><BR>13    chris<BR><BR><BR>## 'everyone else' gets no inheritable capabilities<BR>none  *<BR><BR><BR>## if there is no '*' entry, all users not explicitly mentioned will<BR>## get all available capabilities. This is a permissive default, and<BR>## probably not what you want...<BR>$</pre><BR><BR>Naturally you must have a PAM based authentication process. The PAM configuration files are in /etc/pam.d.<BR>If you like to get the Inheritable Set populated through the login process, your login file may look like<BR><pre>$<BR>$ cat /etc/pam.d/login<BR>#%PAM-1.0<BR>auth        required    pam_securetty.so<BR>auth        include     system-auth<BR>auth        required    pam_cap.so<BR>account     required    pam_nologin.so<BR>account     include     system-auth<BR>password    include     system-auth<BR>session     include     system-auth<BR>session     required    pam_loginuid.so<BR>$</pre></TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Exploring Inheritance">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Exploring Inheritance</TD></TR>
<TR><TD CLASS="tdp">
So if and only if /etc/pam.d/login contains the call of the pam_cap.so PAM Module, we may see the following in exploring the effect of Inheritance.<BR>If we log in as user chris, we will got the CAP_NET_RAW PCap in our Inheritance Set. If we simulate a log in from this shell, the Inheritable Set will go unchanged over to the new process. If we log in per SSH from this shell, we have a new subprocess from init and hence /etc/pam.d/sshd contains no reference to pam_cap, the user will have no PCaps in his Inheritance Set. A simulated log in from here per su leaves obviously the Inheritable Set empty because /etc/pam.d/su also contains no reference to pam_cap.<BR><pre>$<BR>Welcome to Linux 2.6.25-a (tty2)<BR><BR>apollo login: chris<BR>Password:<BR>$ getpcaps $$<BR>Capabilities for `32168': = cap_net_raw+i<BR>$ su - chris<BR>Password:<BR>$ getpcaps $$<BR>Capabilities for `32183': = cap_net_raw+i<BR>$<BR>$ ssh apollo<BR>Last login: Mon May  5 14:36:55 2008 from apollo.friedhoff.loc<BR>Have a nice Day ....<BR>$ getpcaps $$<BR>Capabilities for `32230': =<BR>$ su - chris<BR>Password:<BR>$ getpcaps $$<BR>Capabilities for `32245': =<BR>$<BR>$ pstree -up<BR>init(1)-+-acpid(2422)<BR>        |-agetty(2441)<BR>        |-agetty(2443)<BR>        |-agetty(2445)<BR>        |-agetty(2447)<BR>        |-crond(2417)<BR>        |-dbus-daemon(2403,messagebus)<BR>        |-gpm(32142)<BR>        |-inetd(2390)<BR>        |-klogd(2160)<BR>        |-login(2437)---bash(2461,chris)---vim(32197)<BR>        |-login(31451)---bash(32168,chris)---su(32182)---bash(32183)---ssh(32222)<BR>        |-sleepd(2435)<BR>        |-smartd(2414)<BR>        |-spamd(2429)---spamd(333)<BR>        |-sshd(2394)---sshd(32223)---sshd(32228,chris)---bash(32230)---su(32244)---bash(32245)---pstree(32261)<BR>        |-syslogd(2158)<BR>        |-udevd(1053)<BR>        `-wpa_supplicant(2178)<BR>$<BR>$ getpcaps 31451 32168 32182 32183 32222 2394 32223 32228 32230 32244 32245<BR>Capabilities for `31451': =ep cap_net_raw+i<BR>Capabilities for `32168': = cap_net_raw+i<BR>Capabilities for `32182': = cap_net_raw+i<BR>Capabilities for `32183': = cap_net_raw+i<BR>Capabilities for `32222': = cap_net_raw+i<BR>Capabilities for `2394': =ep<BR>Capabilities for `32223': =ep<BR>Capabilities for `32228': =<BR>Capabilities for `32230': =<BR>Capabilities for `32244': =<BR>Capabilities for `32245': =<BR></pre><BR><BR>A process running in the context of root is kernel intern a process, whose all available PCaps are having the Effective (e) and Permitted (p) Flag. Root has the complete Effective and Permitted Set. The root runned login process 31451 has beside beside the fully equiped EP-Sets also the PCap CAP_NET_RAW with the Inheritable (i) Flag. This Inheritable Set goes unchanged over to the chris owned bash session 32168. According to the Inheritance part of the Capability Rule, this Inheritable Set goes unchanged over from 32168 -> 32182 -> 32183 to finally 32222. Because the configuration of /etc/pam.d/sshd does not populate the Inheritance Set, all the subsequence processes have also an empty Inheritance Set.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - SUID-BIT 0 reloaded">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - SUID-BIT 0 reloaded</TD></TR>
<TR><TD CLASS="tdp">
In the process of substituting the suid-bit-0 configuration with PCaps, we just reduced the amount of privilege these former suid-0 applications are now executed with. We granted the Permitted (p) Flag - Forced Flag - so for every calling process we ensured, that the resulting process will have the needed PCaps available. Due to legacy support, we also granted the Effective (e) Flag.<BR><BR>Now we look again at these applications and their needed PCaps<BR><pre>ping - CAP_NET_RAW (13)<BR>traceroute - CAP_NET_RAW (13)<BR>chsh - CAP_CHOWN (0), CAP_DAC_READ_SEARCH (2), CAP_FSETID (4), CAP_SETUID (7)<BR>chfn - CAP_CHOWN (0), CAP_DAC_READ_SEARCH (2), CAP_FSETID (4), CAP_SETUID (7)<BR>chage - CAP_DAC_READ_SEARCH (2)<BR>passwd - CAP_CHOWN (0), CAP_DAC_OVERRIDE (1), CAP_FOWNER (3)<BR>unix_chkpwd - CAP_DAC_OVERRIDE (1)</pre><BR><BR>We will change the configuration from the Permitted Set toward the Inheritable Set<BR><pre>$<BR>$ sudo setcap 13=ei /bin/ping<BR>$ sudo setcap 13=ei /usr/bin/traceroute<BR>$ sudo setcap 0,2,4,7=ei /ust/bin/chsh<BR>$ sudo setcap 0,2,4,7=ei /usr/bin/chfn<BR>$ sudo setcap 2=ei /usr/bin/chage<BR>$ sudo setcap 0,1,3=ei /usr/bin/passwd<BR>$ sudo setcap 1=ei= /sbin/unix_chkpwd<BR>$</pre><BR><BR>We will grant user chris these PCaps into his Inheritable Set by changing /etc/security/capability.conf<BR><pre>$sudo sed -i 's|.*&#092;(chris&#092;)|0,1,2,3,4,7,13   &#092;1|' /etc/security/capability.conf</pre><BR><BR>and check the configuration, that chris receives an Inheritable Set and anyone else has an empty Inheritable Set (none clause)<BR><pre>$<BR>$ egrep -v "(#|^$)" /etc/security/capability.conf<BR>0,1,2,3,4,7,13   chris<BR>none  *<BR>$</pre><BR><BR>Now we have a configuration, where luser want be able anymore to execute the former suid-bit-0 applications. He is now even less powerful than before. With his Inheritable Set and the applications having also an Inheritable Set, chris is still able to execute these former suid-bit-0 applications.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Convenience">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Convenience</TD></TR>
<TR><TD CLASS="tdp">
To show what is possible, as a proof of concept, I was showing in the past, how to raise the convenience by granting several applications the PCaps to execute successful. But contrary to the former suid-0 applications, these applications where formerly not accessible by the unprivileged user. So the net effect was, that suddenly other unprivileged user might come into the position to do things, they were not allowed before.<BR>So, do your risk analysis and weight up between convenience and a possible security problem before following the examples - you have been warned.<BR>In fact the multi user system Linux is very often used as a single user system and this user also performs some administration tasks. Some applications need only one or a few privileges to execute successful. Through the usage of the technique of Inheritance Sets, we can grant the elected user and the elected applications the needed PCaps in their Inheritance Set, so we can execute these applications without the need of 'sudo' or 'su -c'.<BR><BR>For the following applications I have detected the needed PCaps<BR><pre>eject = CAP_DAC_READ_SEARCH (2), CAP_SYS_RAWIO (17)<BR>ifconfig = CAP_NET_ADMIN (12)<BR>killall = CAP_KILL (5)<BR>modprobe = CAP_SYS_MODULE (16)<BR>ntpdate = CAP_NET_BIND (10), CAP_SYS_TIME (25)<BR>qemu = CAP_NET_ADMIN (12)<BR>route = CAP_NET_ADMIN (12)</pre><BR><BR>Again, we configure the needed PCaps for the applications<BR><pre>$<BR>setcap 2,17=ei /usr/bin/eject<BR>setcap 12=ei /sbin/ifconfig<BR>setcap 5=ei /bin/killall<BR>setcap 16=ei /sbin/modprobe<BR>setcap 10,25=ei /usr/sbin/ntpdate<BR>setcap 12=ei /usr/bin/qemu<BR>setcap 12=ei /sbin/route<BR>$</pre><BR><BR>We will grant user chris also these PCaps into his Inheritable Set by changing /etc/security/capability.conf<BR><pre>$sudo sed -i 's|.*&#092;(chris&#092;)|0,1,2,3,4,5,7,10,12,13,16,17   &#092;1|' /etc/security/capability.conf</pre><BR><BR>and check the configuration, that chris receives an Inheritable Set and anyone else has an empty Inheritable Set (none clause)<BR><pre>$<BR>$ egrep -v "(#|^$)" /etc/security/capability.conf<BR>0,1,2,3,4,5,7,10,12,13,16,17   chris<BR>none  *<BR>$</pre><BR><BR>Here we reached a point, where we are able to provide users with a privilege level below than with suid-0 applications to as far as being able to do some administration task. I believe, that system user - user accounts without real persons behind them - are examples to refuse the ability to - lets say - change account data like passwords and login shells or edit the crontab or do mount and umount operations. On the other hand, a trusted user, who regularly performs administration tasks might be granted some privileges in combination with the appropriate application to perform necessary tasks, without executing them with the privilege level of root trough 'sudo' or 'su -c'.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Different Administration Rolls">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Examples - Types of usage of POSIX Capabilities - Different privilege levels for different user rolls - Different Administration Rolls</TD></TR>
<TR><TD CLASS="tdp">
A nice example is the roll of a back-up administrator. By using the tool - for example tar - the backup process needs privileges above the level of an unprivileged user. We will grant this back-up administrator the privilege of reading root owned system files and files of other user by granting him CAP_READ_SEARCH in his Process Inheritance Set. The back-up tool tar on the other hand will also have these PCaps in his File Inheritance Set. Only a user and here our back-up administrator with the matching PCaps in his Process Inheritance Set will by executing tar populating the Process Permitted Set of this tar process with the privilege to read these files.<BR><BR>A network roll is an other imaginable position. Granting this user and the adequate applications the needed privileges as PCaps with the Inheritable Flag allows only him to execute these applications with the necessary privileges.<BR><BR>Further rolls might be something like a user account administrator or a reboot administrator.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD><A NAME="Lectures, Talks and Presentations">&nbsp;</A></TD></TR><TR><TD CLASS="tdn">Lectures, Talks and Presentations</TD></TR>
<TR><TD CLASS="tdp">
I have presented 'POSIX File Capabilities' at the <a href="http://chemnitzer.linux-tage.de/">Chemnitzer Linux-Tage 2008</a> in the <a href="http://chemnitzer.linux-tage.de/2008/vortraege/plan-programm.html">security track</a> Saturday March the first.<BR><BR>I have presented <a href="http://www.linuxtag.org/2008/de/conf/events/vp-events/vortragsdetails.html?talkid=155">'POSIX {,File} Capabilities - killall suid-0 binaries and far beyond'</a> at the <a href="http://www.linuxtag.org/2008/">Linuxtag 2008</a> in Berlin <a href="http://www.linuxtag.org/2008/de/conf/events/vp-freitag.html">Friday May 30th</a>.<BR><BR>You will find the presentations and papers on the <a href="/downloads.html">download page</a>.</TD></TR>
<TR><TD CLASS="tds"><A HREF="#top" CLASS="af">top</A>&nbsp;</TD></TR>
<TR><TD CLASS="tdp"><h3>Licence</h3><BR>The content of this page is published under the <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Licence</a>.</TD></TR>
</TABLE></td></tr>
<tr><td colspan="2" class="tdh"><table class="te"><tr><td class="tdi">Chris Friedhoff</td></tr></table></td></tr>
<tr><td>&nbsp;</td><td class="tdj"><table class="tf">
<tr><td class="tdk"><div id="sitemap"><ul><LI>Sitemap<ul>
<LI><a href="/index.html">Home</a></LI>
<LI><a href="/lifebook.html">LifeBook</a></LI>
<LI><a href="/ma311.html">MA311</a></LI>
<LI><a href="/survivingvim.html">SurvivingVim</a></LI>
<LI><a href="/playingvim.html">PlayingVim</a></LI>
<LI><a href="/survivingshell.html">SurvivingShell</a></LI>
<LI><a href="/lesezugriff.html">Lesezugriff</a></LI>
<LI><a href="/posixfilecaps.html">POSIXFileCaps</a></LI>
<LI><a href="/downloads.html">Downloads</a></LI>
<LI><a href="/odin.html">Odin</a></LI>
<LI><a href="/about.html">About</a></LI>
<LI><a href="/email.html">Email</a></LI>
</ul></LI></ul></div>
</td></tr>
<tr><td class="tdk">Chris Friedhoff</td></tr>
<tr><td class="tdk">Copyright &copy; 2006 by Chris Friedhoff - all rights reserved, alle Rechte vorbehalten.</td></tr>
<tr><td class="tdk"><a href="email.html" class="ad">info@friedhoff.org</a></td></tr>
<tr><td class="tdk">last modified: Sun, 01 Jun 2008 07:13:27 GMT</td></tr>
</table>
</td></tr></table>
</body>
</html>